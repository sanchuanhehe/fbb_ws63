# 前言<a name="ZH-CN_TOPIC_0000001880631385"></a>

**概述<a name="section64031159132213"></a>**

本文档主要描述了CIPHER DRIVER的结构及其软件接口的使用方法。

**产品版本<a name="section278mcpsimp"></a>**

与本文档相对应的产品版本如下。

<a name="table281mcpsimp"></a>
<table><thead align="left"><tr id="row286mcpsimp"><th class="cellrowborder" valign="top" width="45%" id="mcps1.1.3.1.1"><p id="p288mcpsimp"><a name="p288mcpsimp"></a><a name="p288mcpsimp"></a>产品名称</p>
</th>
<th class="cellrowborder" valign="top" width="55.00000000000001%" id="mcps1.1.3.1.2"><p id="p290mcpsimp"><a name="p290mcpsimp"></a><a name="p290mcpsimp"></a>产品版本</p>
</th>
</tr>
</thead>
<tbody><tr id="row292mcpsimp"><td class="cellrowborder" valign="top" width="45%" headers="mcps1.1.3.1.1 "><p id="p294mcpsimp"><a name="p294mcpsimp"></a><a name="p294mcpsimp"></a>WS63</p>
</td>
<td class="cellrowborder" valign="top" width="55.00000000000001%" headers="mcps1.1.3.1.2 "><p id="p296mcpsimp"><a name="p296mcpsimp"></a><a name="p296mcpsimp"></a>V100</p>
</td>
</tr>
</tbody>
</table>

**读者对象<a name="section297mcpsimp"></a>**

本文档主要适用于以下工程师：

-   技术支持工程师
-   软件开发工程师

**符号约定<a name="section303mcpsimp"></a>**

在本文中可能出现下列标志，它们所代表的含义如下。

<a name="table306mcpsimp"></a>
<table><thead align="left"><tr id="row311mcpsimp"><th class="cellrowborder" valign="top" width="21%" id="mcps1.1.3.1.1"><p id="p313mcpsimp"><a name="p313mcpsimp"></a><a name="p313mcpsimp"></a><strong id="b314mcpsimp"><a name="b314mcpsimp"></a><a name="b314mcpsimp"></a>符号</strong></p>
</th>
<th class="cellrowborder" valign="top" width="79%" id="mcps1.1.3.1.2"><p id="p316mcpsimp"><a name="p316mcpsimp"></a><a name="p316mcpsimp"></a><strong id="b317mcpsimp"><a name="b317mcpsimp"></a><a name="b317mcpsimp"></a>说明</strong></p>
</th>
</tr>
</thead>
<tbody><tr id="row319mcpsimp"><td class="cellrowborder" valign="top" width="21%" headers="mcps1.1.3.1.1 "><p class="msonormal" id="p321mcpsimp"><a name="p321mcpsimp"></a><a name="p321mcpsimp"></a><a name="image123"></a><a name="image123"></a><span><img id="image123" src="figures/zh-cn_image_0000001833673048.png" height="23.94" width="67.83"></span></p>
</td>
<td class="cellrowborder" valign="top" width="79%" headers="mcps1.1.3.1.2 "><p id="p323mcpsimp"><a name="p323mcpsimp"></a><a name="p323mcpsimp"></a>表示如不避免则将会导致死亡或严重伤害的具有高等级风险的危害。</p>
</td>
</tr>
<tr id="row324mcpsimp"><td class="cellrowborder" valign="top" width="21%" headers="mcps1.1.3.1.1 "><p class="msonormal" id="p326mcpsimp"><a name="p326mcpsimp"></a><a name="p326mcpsimp"></a><a name="image124"></a><a name="image124"></a><span><img id="image124" src="figures/zh-cn_image_0000001833832832.png" height="23.94" width="67.83"></span></p>
</td>
<td class="cellrowborder" valign="top" width="79%" headers="mcps1.1.3.1.2 "><p id="p328mcpsimp"><a name="p328mcpsimp"></a><a name="p328mcpsimp"></a>表示如不避免则可能导致死亡或严重伤害的具有中等级风险的危害。</p>
</td>
</tr>
<tr id="row329mcpsimp"><td class="cellrowborder" valign="top" width="21%" headers="mcps1.1.3.1.1 "><p class="msonormal" id="p331mcpsimp"><a name="p331mcpsimp"></a><a name="p331mcpsimp"></a><a name="image125"></a><a name="image125"></a><span><img id="image125" src="figures/zh-cn_image_0000001880632121.png" height="23.94" width="67.83"></span></p>
</td>
<td class="cellrowborder" valign="top" width="79%" headers="mcps1.1.3.1.2 "><p id="p333mcpsimp"><a name="p333mcpsimp"></a><a name="p333mcpsimp"></a>表示如不避免则可能导致轻微或中度伤害的具有低等级风险的危害。</p>
</td>
</tr>
<tr id="row334mcpsimp"><td class="cellrowborder" valign="top" width="21%" headers="mcps1.1.3.1.1 "><p class="msonormal" id="p336mcpsimp"><a name="p336mcpsimp"></a><a name="p336mcpsimp"></a><a name="image126"></a><a name="image126"></a><span><img id="image126" src="figures/zh-cn_image_0000001880472333.png" height="23.94" width="67.83"></span></p>
</td>
<td class="cellrowborder" valign="top" width="79%" headers="mcps1.1.3.1.2 "><p id="p338mcpsimp"><a name="p338mcpsimp"></a><a name="p338mcpsimp"></a>用于传递设备或环境安全警示信息。如不避免则可能会导致设备损坏、数据丢失、设备性能降低或其它不可预知的结果。</p>
<p id="p339mcpsimp"><a name="p339mcpsimp"></a><a name="p339mcpsimp"></a>“须知”不涉及人身伤害。</p>
</td>
</tr>
<tr id="row340mcpsimp"><td class="cellrowborder" valign="top" width="21%" headers="mcps1.1.3.1.1 "><p class="msonormal" id="p342mcpsimp"><a name="p342mcpsimp"></a><a name="p342mcpsimp"></a><a name="image127"></a><a name="image127"></a><span><img id="image127" src="figures/zh-cn_image_0000001833673052.png" height="23.94" width="67.83"></span></p>
</td>
<td class="cellrowborder" valign="top" width="79%" headers="mcps1.1.3.1.2 "><p id="p344mcpsimp"><a name="p344mcpsimp"></a><a name="p344mcpsimp"></a>对正文中重点信息的补充说明。</p>
<p id="p345mcpsimp"><a name="p345mcpsimp"></a><a name="p345mcpsimp"></a>“说明”不是安全警示信息，不涉及人身、设备及环境伤害信息。</p>
</td>
</tr>
</tbody>
</table>

**修改记录<a name="section346mcpsimp"></a>**

<a name="table348mcpsimp"></a>
<table><thead align="left"><tr id="row354mcpsimp"><th class="cellrowborder" valign="top" width="21%" id="mcps1.1.4.1.1"><p id="p356mcpsimp"><a name="p356mcpsimp"></a><a name="p356mcpsimp"></a><strong id="b357mcpsimp"><a name="b357mcpsimp"></a><a name="b357mcpsimp"></a>文档版本</strong></p>
</th>
<th class="cellrowborder" valign="top" width="26%" id="mcps1.1.4.1.2"><p id="p359mcpsimp"><a name="p359mcpsimp"></a><a name="p359mcpsimp"></a><strong id="b360mcpsimp"><a name="b360mcpsimp"></a><a name="b360mcpsimp"></a>发布日期</strong></p>
</th>
<th class="cellrowborder" valign="top" width="53%" id="mcps1.1.4.1.3"><p id="p362mcpsimp"><a name="p362mcpsimp"></a><a name="p362mcpsimp"></a><strong id="b363mcpsimp"><a name="b363mcpsimp"></a><a name="b363mcpsimp"></a>修改说明</strong></p>
</th>
</tr>
</thead>
<tbody><tr id="row16625121412313"><td class="cellrowborder" valign="top" width="21%" headers="mcps1.1.4.1.1 "><p id="p10626141462311"><a name="p10626141462311"></a><a name="p10626141462311"></a>02</p>
</td>
<td class="cellrowborder" valign="top" width="26%" headers="mcps1.1.4.1.2 "><p id="p18626161419230"><a name="p18626161419230"></a><a name="p18626161419230"></a>2024-06-27</p>
</td>
<td class="cellrowborder" valign="top" width="53%" headers="mcps1.1.4.1.3 "><p id="p196261014152316"><a name="p196261014152316"></a><a name="p196261014152316"></a>更新“<a href="使用流程.md">使用流程</a>”章节内容。</p>
<p id="p242453414231"><a name="p242453414231"></a><a name="p242453414231"></a>更新“<a href="错误类型.md">错误类型</a>”章节内容。</p>
</td>
</tr>
<tr id="row117961384314"><td class="cellrowborder" valign="top" width="21%" headers="mcps1.1.4.1.1 "><p id="p118382762110"><a name="p118382762110"></a><a name="p118382762110"></a>01</p>
</td>
<td class="cellrowborder" valign="top" width="26%" headers="mcps1.1.4.1.2 "><p id="p171834279217"><a name="p171834279217"></a><a name="p171834279217"></a>2024-04-10</p>
</td>
<td class="cellrowborder" valign="top" width="53%" headers="mcps1.1.4.1.3 "><p id="p618317279212"><a name="p618317279212"></a><a name="p618317279212"></a>第一次正式版本发布。</p>
</td>
</tr>
<tr id="row365mcpsimp"><td class="cellrowborder" valign="top" width="21%" headers="mcps1.1.4.1.1 "><p id="p367mcpsimp"><a name="p367mcpsimp"></a><a name="p367mcpsimp"></a>00B01</p>
</td>
<td class="cellrowborder" valign="top" width="26%" headers="mcps1.1.4.1.2 "><p id="p369mcpsimp"><a name="p369mcpsimp"></a><a name="p369mcpsimp"></a>2024-03-29</p>
</td>
<td class="cellrowborder" valign="top" width="53%" headers="mcps1.1.4.1.3 "><p id="p371mcpsimp"><a name="p371mcpsimp"></a><a name="p371mcpsimp"></a>第一次临时版本发布。</p>
</td>
</tr>
</tbody>
</table>

# 概述<a name="ZH-CN_TOPIC_0000001833669648"></a>



## 功能描述<a name="ZH-CN_TOPIC_0000001880468929"></a>

CIPHER DRIVER为安全算法模块，对外提供mbedtls API 和service layer两类接口，如[图1](#fig727383712313)所示。

-   mbedtls API
    -   安全驱动对接开源第三方mbedtls接口，可以通过调用mbedtls API使用硬件安全能力。
    -   对于硬件支持的规格，均完成mbedtls对接，硬化范围及API使用具体参考《WS63V100 TLS&DTLS 开发指南》。

-   service layer
    -   自研安全驱动接口，为上层业务提供直接使用硬件安全的能力，支持LiteOS/FreeRTOS/AliOS等OS环境，及flashboot/bootrom等无OS环境。

-   CIPHER DRIVER提供如下算法：
    -   AES、SM4等对称加解密算法.
    -   HASH、SM3及HASH-MAC、SM3-MAC摘要算法.
    -   RSA、ECC、SM2签名验签、密钥协商、加解密，大数运算等非对称算法.
    -   硬件密钥管理.
    -   随机数算法.
    -   FLASH在线解密.
    -   主要用于AIOT产品安全启动、安全存储、安全通讯等场景。

-   CIPHER DRIVER包括5个子模块：SPACC（symc、hash）、PKE、KM、TRNG、FAPC。

**图 1**  CIPHER　DRIVER上下文关系图<a name="fig727383712313"></a>  
![](figures/CIPHER-DRIVER上下文关系图.png "CIPHER-DRIVER上下文关系图")






### SPACC<a name="ZH-CN_TOPIC_0000001880628701"></a>

SPACC（Security Protocol Accelerator，安全协议加速器）模块实现了cipher对称加解密算法、HASH及HMAC摘要算法。



#### 对称加解密算法<a name="ZH-CN_TOPIC_0000001833829428"></a>

-   AES：支持ECB/CBC/CFB/OFB/CTR/CCM/GCM/CMAC/CBC\_MAC共9种工作模式。其中：
    -   CFB模式支持的加密数据位宽可为8/128bit。
    -   OFB模式支持的加密数据位宽可为128bit。
    -   CCM/GCM模式下，加解密结束后需获取一次TAG值。
    -   ECB、CBC、CBC\_MAC模式加密数据长度必须为16Byte对齐，CMAC允许最后一块加密数据长度非16Byte对齐。
    -   支持AES-128、AES-192、AES-256（128、192、256均指传入的密钥长度，单位为bit）。

-   SM4：支持ECB/CBC/CTR/CFB/OFB共5种工作模式。支持SM4-128；除CTR模式外，加密数据长度须为16Byte对齐。

cipher驱动支持软件多通道，各芯片可以根据自己需要在porting文件中配置；支持低功耗模式，默认开启低功耗；支持轮询和wait\_event模式，若注册了wait func则走wait\_event模式，否则走轮询模式。

>![](public_sys-resources/icon-note.gif) **说明：** 
>ECB模式属于非安全算法，不建议使用。

#### 摘要算法<a name="ZH-CN_TOPIC_0000001833669652"></a>

-   HASH：支持SHA1/SHA224/SHA256/SHA384/SHA512/SM3。
-   HMAC：支持HMAC-SHA1/HMAC-SHA224/HMAC-SHA256/HMAC-SHA384/HMAC-SHA512/HMAC-SM3。

HASH和HMAC支持中途传入非block size对齐的数据块；支持软件多通道，各芯片可以根据自己需要在porting文件中配置；支持低功耗模式，默认开启低功耗；支持轮询和wait\_event模式，若注册了wait func则走wait\_event模式，否则走轮询模式。HASH支持重试机制，即中间过程调用接口出错可重新调用该接口直至成功，而不需要从头开始整个计算流程，具体内容请参见《WS63V100 SECURITY DRIVER  API manual》中uapi\_drv\_cipher\_hash\_start、uapi\_drv\_cipher\_hash\_update 和uapi\_drv\_cipher\_hash\_finish接口使用说明。

>![](public_sys-resources/icon-note.gif) **说明：** 
>SHA1/SHA224属于非安全算法，不建议使用。

### PKE<a name="ZH-CN_TOPIC_0000001880468933"></a>

PKE（Public Key Encryption，公钥加密），即非对称加解密算法。常用于文件的签名和验签，以及对对称密钥的加解密，主要包括以下算法：

-   RSA
    -   支持PKCS\#1 v1.5和 PKCS\#1 v2.1PSS两种模式的私钥签名和公钥验签。
    -   支持PKCS\#1 v1.5 和 PKCS\#1 v2.1OAEP两种模式的公钥加密和私钥解密。
    -   支持密钥位宽1024/2048/3072/4096。

-   ECC
    -   支持 RFC 5639-Brainpool P256/384/512r1、NIST FIPS 186-4 P192/224/256/384/521 和 RFC 8032-ED25519（即EDDSA）的私钥签名和公钥验签。
    -   支持密钥位宽192/224/256/384/512\(521\)。

-   SM2
    -   支持SM2公钥加密和私钥解密。
    -   支持SM2私钥签名和公钥验签。

-   密钥协商
    -   支持RFC 5639-Brainpool P256/384/512r1、NIST FIPS 186-4 P192/224/256/384/521、RFC 7748-Curve25519/Curve448、 RFC 8032 - ED25519（即EDDSA）和SM2的公私钥对生成，及由给定的私钥生成其对应的公钥。
    -   支持RFC 5639-Brainpool P256/384/512r1、NIST FIPS 186-4 P192/224/256/384/521、RFC 7748-Curve25519/Curve448和SM2的密钥交换（ECDH）。
    -   支持192/224/256/384/512/521/1024/2048/3072/4096比特DH密钥协商。

-   曲线上点的验证
    -   支持RFC 5639-Brainpool P256/384/512r1、NIST FIPS 186-4 P192/224/256/384/521和SM2的点是否在曲线上的验证。

-   大数运算
    -   支持小于等于4096位的模加、模减、模乘、模逆、模幂和模运算。
    -   支持小于等于2048位的常规大数乘运算。

PKE支持低功耗模式，并默认开启低功耗。支持轮询和wait\_event模式，若注册了wait func则走wait\_event模式，否则走轮询模式。

>![](public_sys-resources/icon-note.gif) **说明：** 
>NIST FIPS 186-4 P192/224/256/384/521，PKCS\#1 v1.5，RSA1024/2048，低于256比特的ECDH及低于2048bit的DH为不安全算法，不建议使用。

### KM<a name="ZH-CN_TOPIC_0000001880628705"></a>

KM是密钥管理模块，增加密钥安全强度，用于将key加载到keyslot中，供SPACC和Flash在线解密使用。支持硬件key和软件key；支持8个cipher keyslot通道和2个hmac keyslot通道。

### TRNG<a name="ZH-CN_TOPIC_0000001833829432"></a>

随机数获取模块，获取硬件产生的真随机数。

### FAPC<a name="ZH-CN_TOPIC_0000001833669656"></a>

通过fapc控制器，配置flash在线解密操作相关的参数。fapc支持配置4个region，支持region使用相同的IV值，flash在线解密使用AES-128-CTR算法。

## 使用流程<a name="ZH-CN_TOPIC_0000001880468937"></a>

系统初始化时会主动调用uapi\_drv\_cipher\_env\_init完成CIPHER DRIVER基础的初始化环境配置，用户不需要再单独调用。

















### 密钥配置<a name="ZH-CN_TOPIC_0000001880628709"></a>





#### 场景说明<a name="ZH-CN_TOPIC_0000001833829436"></a>

生成和配置SPACC、在线解密模块所需要的软件key和硬件Key，软件key可由PBKDF2和HKDF算法生成。keyslot存放最终的软件或硬件key，供SPACC和在线解密使用。支持 AES 128/192/256bits加解密，支持HMAC。

#### 软件密钥配置工作流程<a name="ZH-CN_TOPIC_0000001833669660"></a>

1.  调用uapi\_drv\_km\_init初始化KM模块。
2.  创建keyslot通道，FLASH在线解密不需要此操作，调用uapi\_drv\_keyslot\_create接口完成。（若配置的key供SPACC模块调用，则该步骤在调用者调用SPACC模块接口绑定keyslot通道前完成）。
3.  创建一路klad，并获取klad句柄。调用uapi\_drv\_klad\_create接口完成。
4.  绑定keyslot通道与klad句柄，调用uapi\_drv\_klad\_attach接口完成。步骤2、步骤4的顺序可以调换。
5.  配置klad属性。包含：

    -   密钥对应的root\_key类型。
    -   密码可用于的算法。
    -   密钥可用于加密还是解密操作。
    -   密钥是安全还是非安全密钥。
    -   密钥是否仅可被配置该密钥的CPU使用。
    -   源和目的buffer类型是安全还是非安全（详见下方说明）。

    调用uapi\_drv\_klad\_set\_attr接口完成。

6.  配置软件key，调用uapi\_drv\_klad\_set\_clear\_key接口完成。SPACC
7.  解绑keyslot与klad句柄，对于FLASH在线解密操作则是指定对应操作类型，调用uapi\_drv\_klad\_detach接口完成。
8.  销毁klad句柄，调用uapi\_drv\_klad\_destroy接口完成。
9.  销毁keyslot句柄，调用uapi\_drv\_keyslot\_destroy接口完成。
10. 调用uapi\_drv\_km\_deinit去初始化KM模块。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >klad配置的源和目的buffer类型与SPACC模块 buffer类型相对应，如果此处配置源数据buffer为仅支持安全buffer，而SPACC模块源buffer配置为非安全buffer，则计算过程中会报错。步骤9、步骤10的操作需要在SPACC、HMAC、FLASH在线解密使用完keyslot之后再执行，不然后导致计算报错。

#### 硬件密钥配置工作流程<a name="ZH-CN_TOPIC_0000001880468941"></a>

1.  调用uapi\_drv\_km\_init初始化KM模块。
2.  创建keyslot通道，FLASH在线解密不需要此操作，调用uapi\_drv\_keyslot\_create接口完成。（若配置的key供SPACC模块调用，则该步骤在调用者调用SPACC模块接口绑定keyslot通道前完成）。
3.  创建一路klad，并获取klad句柄。调用uapi\_drv\_klad\_create接口完成。
4.  绑定keyslot通道与klad句柄，对于在FLASH线解密操作则是指定对应操作类型，调用uapi\_drv\_klad\_attach接口完成。步骤2、步骤4的顺序可以调换。
5.  配置klad属性。包含：

    -   密钥对应的root\_key类型。
    -   密码可用于的算法。
    -   密钥可用于加密还是解密操作。
    -   密钥是安全还是非安全密钥。
    -   密钥是否仅可被配置该密钥的CPU使用。
    -   源和目的buffer类型是安全还是非安全（详见下方说明）。

    调用uapi\_drv\_klad\_set\_attr接口完成。

6.  配置硬件key，调用uapi\_drv\_klad\_set\_effective\_key接口完成。
7.  解绑keyslot与klad句柄，对于FLASH在线解密操作则是指定对应操作类型，调用uapi\_drv\_klad\_detach接口完成。
8.  销毁klad句柄，调用uapi\_drv\_klad\_destroy接口完成。
9.  销毁keyslot句柄，调用uapi\_drv\_keyslot\_destroy接口完成。
10. 调用uapi\_drv\_km\_deinit去初始化KM模块。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >-   klad配置的源和目的buffer类型与SPACC模块 buffer类型相对应，如果此处配置源数据buffer为仅支持安全buffer，而SPACC模块源buffer配置为非安全buffer，则计算过程中会报错。步骤9、步骤10的操作需要在SPACC、HMAC、FLASH在线解密使用完keyslot之后再执行，不然后导致计算报错。
    >-   硬件key配置需要烧写对应efuse才可在keyslot通道中获得其对应的正确的工作key，否则此key用于计算得到的结果是错误的，具体efuse烧写过程请参见“[1.2.16 安全相关efuse烧写建议](安全相关efuse烧写建议.md)”小节。

#### 注意事项<a name="ZH-CN_TOPIC_0000001880628713"></a>

硬件密钥配置依赖对应EFUSE，具体efuse烧写方式详见“[安全相关efuse烧写建议](安全相关efuse烧写建议.md)”小节。

### 对称加解密<a name="ZH-CN_TOPIC_0000001833829440"></a>




#### 场景说明<a name="ZH-CN_TOPIC_0000001833669664"></a>

对数据进行加密或解密，支持以下场景数据的加解密操作：

-   源数据所在位置为DDR、RAM、flash。
-   目的数据所在位置为DDR、RAM。

支持原地加解密操作，即输入和输出使用同一块buffer地址。

#### 工作流程<a name="ZH-CN_TOPIC_0000001880468945"></a>

1.  调用uapi\_drv\_cipher\_symc\_init初始化SYMC模块
2.  建一路symc，并获取symc句柄。调用uapi\_drv\_cipher\_symc\_create接口完成。
3.  创建keyslot通道，调用uapi\_drv\_keyslot\_create接口完成。
4.  绑定keyslot通道与symc句柄。调用uapi\_drv\_cipher\_symc\_attach接口完成。keyslot通道创建可参考KEYSLOT&KLAD相关接口说明。
5.  <a name="li845893131117"></a>配置symc算法参数信息。包含：

    -   密钥基本属性（长度、奇偶属性）。
    -   初始向量。
    -   加解密位宽（CFB/OFB模式）。
    -   密钥更新方式（每次重新设置IV/使用上个数据包配置的IV）。
    -   Additional Authenticated Data（GCM/CCM模式）。

    调用接口uapi\_drv\_cipher\_symc\_set\_config接口完成。

6.  <a name="li858441161019"></a>对数据进行加解密。用户可以调用以下任一接口进行加解密。
    -   加密：uapi\_drv\_cipher\_symc\_encrypt
    -   解密：uapi\_drv\_cipher\_symc\_decrypt

7.  如果是CCM、GCM模式，则需要继续调用uapi\_drv\_cipher\_symc\_get\_tag接口获取TAG值，否则直接执行[步骤8](#li1458421120101)。
8.  <a name="li1458421120101"></a>解绑keyslot通道与cipher句柄，调用uapi\_drv\_cipher\_symc\_detach接口完成。
9.  销毁symc句柄，调用uapi\_drv\_cipher\_symc\_destroy接口完成。
10. 调用uapi\_drv\_cipher\_symc\_deinit去初始化SYMC模块

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >[步骤5](#li845893131117)配置好后，允许多包使用相同的配置信息，[步骤6](#li858441161019)的操作可在此基础上连续进行。此时场景类似于[步骤5](#li845893131117)配置IV更新方式为使用上个数据包配置的IV（CRYPTO\_SYMC\_CCM\_IV\_DO\_NOT\_CHANGE/UAPI\_DRV\_CIPHER\_SYMC\_GCM\_IV\_DO\_NOT\_CHANGE/UAPI\_DRV\_CIPHER\_SYMC\_CCM\_IV\_DO\_NOT\_CHANGE）的场景。

#### 注意事项<a name="ZH-CN_TOPIC_0000001880628721"></a>

-   支持 AES ECB/CBC/CFB/OFB/CTR/CCM/GCM共7种模式。
    -   对于ECB/CBC/CFB/OFB/CTR模式，支持重试，即在调用uapi\_drv\_cipher\_symc\_encrypt/uapi\_drv\_cipher\_symc\_decrypt接口失败时，仍可配置正确参数后继续重新调用该接口，完成后续数据加解密。
    -   对于CCM/GCM模式支持重试，即在调用uapi\_drv\_cipher\_symc\_encrypt/uapi\_drv\_cipher\_symc\_decrypt或uapi\_drv\_cipher\_symc\_get\_tag接口失败时，仍可配置正确参数后继续重新调用该接口，完成后续数据加解密。

-   支持软件多通道。
    -   可同时进行多个数据加解密操作，即执行步骤2启动运算，在本次运算未完成（即未执行[步骤8](工作流程.md#li1458421120101)）之前，可申请一个新通道，启动另一个数据加解密运算，直到申请不到通道为止。
    -   最多支持的软件通道数，可由各芯片在porting文件中自己配置。

### MAC值获取<a name="ZH-CN_TOPIC_0000001833829444"></a>




#### 场景说明<a name="ZH-CN_TOPIC_0000001833669668"></a>

获取数据mac值，支持以下场景：源数据所在位置为DDR、RAM、flash。

#### 工作流程<a name="ZH-CN_TOPIC_0000001880468949"></a>

1.  调用uapi\_drv\_cipher\_symc\_init初始化SYMC模块。
2.  创建一路symc，并获取symc句柄，配置mac计算需要的参数信息。包含：

    -   密钥基本属性（长度、奇偶属性）。
    -   加解密位宽。
    -   使用的keyslot通道，keyslot通道创建可参考KEYSLOT&KLAD相关接口说明。

    调用uapi\_drv\_cipher\_mac\_start接口完成。

3.  对数据进行加密，调用uapi\_drv\_cipher\_mac\_update接口完成（可调用一次或多次）。
4.  获取MAC值，并销毁句柄，调用uapi\_drv\_cipher\_mac\_finish接口完成。
5.  调用uapi\_drv\_cipher\_symc\_deinit接口，去初始化SYMC模块。

#### 注意事项<a name="ZH-CN_TOPIC_0000001880628725"></a>

-   支持AES CBC\_MAC 和 AES CMAC两种模式。
-   支持软件多通道。
    -   可同时进行多个数据加解密操作。即执行步骤2启动运算，在本次运算未完成（即未执行步骤4）之前，可申请一个新通道，启动另一个数据加解密运算，直到申请不到通道为止。
    -   最多支持的软件通道数，可由各芯片在porting文件中自己配置。

### HASH计算<a name="ZH-CN_TOPIC_0000001833829448"></a>




#### 场景说明<a name="ZH-CN_TOPIC_0000001833669672"></a>

获取消息摘要，支持以下场景：源数据所在位置为DDR、RAM、flash。

#### 工作流程<a name="ZH-CN_TOPIC_0000001880468953"></a>

1.  调用uapi\_drv\_cipher\_hash\_init初始化HASH模块。
2.  创建一路hash，配置当前hash计算类型，并获取hash句柄。调用uapi\_drv\_cipher\_hash\_start接口完成。
3.  传入消息数据，对消息进行摘要计算，调用uapi\_drv\_cipher\_hash\_update接口完成。
4.  获取消息摘要，调用uapi\_drv\_cipher\_hash\_finish接口完成。
5.  调用uapi\_drv\_cipher\_hash\_deinit去初始化HASH模块。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >步骤4如果成功会自己销毁hash句柄，不需要额外调用hash接口。步骤2启动成功后，无论后续步骤成功或失败，均可调用uapi\_drv\_cipher\_hash\_destroy接口销毁hash句柄（步骤4成功除外）。

#### 注意事项<a name="ZH-CN_TOPIC_0000001880628729"></a>

-   在调用uapi\_drv\_cipher\_hash\_finish接口获取消息摘要时，传入的result buffer需要调用者申请，其大小为result\_len，且result\_len不应小于当前hash类型对应的摘要计算结果长度。
-   支持多段数据连续update，结果与多段数据一次性update结果一致。
-   支持hash clone操作，即通过uapi\_drv\_cipher\_hash\_get接口拷贝当前hash handle1信息，通过uapi\_drv\_cipher\_hash\_set接口设置至另一个hash handle2，由新的hash handle2继续完成后续计算操作。若hash handle1与hash handle2后续计算操作一致，则两者最终得到的hash摘要结果一致。
-   支持重试，即在调用uapi\_drv\_cipher\_hash\_update/uapi\_drv\_cipher\_hash\_finish接口失败时，仍可配置正确参数后继续重新调用该接口，完成后续摘要计算操作。

### HMAC计算<a name="ZH-CN_TOPIC_0000001833829452"></a>




#### 场景说明<a name="ZH-CN_TOPIC_0000001833669676"></a>

依赖调用者传入的密钥数据，获取消息摘要，该密钥数据由消息交换双方提前协商好。支持以下场景：源数据所在位置为DDR、RAM、flash。

#### 工作流程<a name="ZH-CN_TOPIC_0000001880468957"></a>

1.  调用uapi\_drv\_cipher\_hash\_init初始化HASH模块。
2.  创建一路hash，配置当前hash计算类型和密钥所在keyslot通道，并获取hash句柄。调用uapi\_drv\_cipher\_hash\_start接口完成。
3.  传入消息数据，对消息进行摘要计算，调用uapi\_drv\_cipher\_hash\_update接口完成。
4.  <a name="li142717119487"></a>获取消息摘要，调用uapi\_drv\_cipher\_hash\_finish接口完成。
5.  调用uapi\_drv\_cipher\_hash\_deinit去初始化HASH模块。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >步骤4如果成功会自己销毁hash句柄，不需要额外调用hash接口。步骤2启动成功后，无论后续步骤成功或失败，均可调用uapi\_drv\_cipher\_hash\_destroy接口销毁hash句柄（[步骤5](#li142717119487)成功除外）。

#### 注意事项<a name="ZH-CN_TOPIC_0000001880628733"></a>

在调用uapi\_drv\_cipher\_hash\_finish接口获取消息摘要时，传入的result buffer需要调用者申请，其大小为result\_len，且result\_len不应小于当前hash类型对应的摘要计算结果长度。

调用者传入的密钥数据，如果是明文密钥，则要求密钥长度不能大于当前hash类型的block\_size大小，如果密钥长度大于当前hash类型的block\_size大小，则需要调用者先对密钥进行hash计算，使得其长度小于block\_size。如果是密文密钥，则密钥长度只能为16 bytes、24bytes或32 bytes。

### RSA加解密<a name="ZH-CN_TOPIC_0000001833829456"></a>




#### 场景说明<a name="ZH-CN_TOPIC_0000001833669680"></a>

RSA加解密应用场景为公钥加密私钥解密。

#### 工作流程<a name="ZH-CN_TOPIC_0000001880468961"></a>

1.  公钥加密，调用uapi\_drv\_cipher\_pke\_rsa\_public\_encrypt接口完成。
2.  私钥解密，调用uapi\_drv\_cipher\_pke\_rsa\_private\_decrypt接口完成。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >调用加密接口时，存储加密结果的buffer，其缓冲区大小不能小于密钥N的位宽。

#### 注意事项<a name="ZH-CN_TOPIC_0000001880628737"></a>

支持PKCS\#1 v1.5 和 PKCS\#1 v2.1 OAEP两种模式，且用户标签数据（label）可选，该label仅在PKCS\#1 v2.1 OAEP模式下使用。PKCS\#1 v1.5为不安全算法，不建议使用。

### RSA签名验签<a name="ZH-CN_TOPIC_0000001833829460"></a>




#### 场景说明<a name="ZH-CN_TOPIC_0000001833669684"></a>

RSA签名验签主要应用场景是私钥签名公钥验签。

#### 工作流程<a name="ZH-CN_TOPIC_0000001880468965"></a>

1.  私钥签名，调用uapi\_drv\_cipher\_pke\_rsa\_sign接口完成。
2.  公钥验签，调用uapi\_drv\_cipher\_pke\_rsa\_verify接口完成。

#### 注意事项<a name="ZH-CN_TOPIC_0000001880628741"></a>

支持 PKCS\#1 v1.5和 PKCS\#1 v2.1 PSS两种模式的私钥签名和公钥验签。PKCS\#1 v1.5为不安全算法，不建议使用。

### SM2加解密<a name="ZH-CN_TOPIC_0000001833829464"></a>



#### 场景说明<a name="ZH-CN_TOPIC_0000001833669688"></a>

SM2加解密应用场景是公钥加密私钥解密。

#### 工作流程<a name="ZH-CN_TOPIC_0000001880468969"></a>

1.  公钥加密，调用uapi\_drv\_cipher\_pke\_sm2\_public\_encrypt接口完成。
2.  私钥解密，调用uapi\_drv\_cipher\_pke\_sm2\_private\_decrypt接口完成。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >加解密所需要的公私钥对可调用uapi\_drv\_cipher\_pke\_ecc\_gen\_key生成。

### SM2签名验签<a name="ZH-CN_TOPIC_0000001880628745"></a>



#### 场景说明<a name="ZH-CN_TOPIC_0000001833829472"></a>

SM2签名验签主要应用场景是私钥签名公钥验签。

#### 工作流程<a name="ZH-CN_TOPIC_0000001833669692"></a>

1.  生成消息对应的hash摘要，调用uapi\_drv\_cipher\_pke\_sm2\_dsa\_hash接口完成。
2.  私钥签名，调用uapi\_drv\_cipher\_pke\_ecdsa\_sign接口完成。
3.  公钥验签，调用uapi\_drv\_cipher\_pke\_ecdsa\_verify接口完成。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >签名验签所需要的公私钥对可调用uapi\_drv\_cipher\_pke\_ecc\_gen\_key接口生成，可以调用uapi\_drv\_cipher\_pke\_check\_dot\_on\_curve接口以确认公钥确实是曲线上的点。

### ECC签名验签<a name="ZH-CN_TOPIC_0000001880468973"></a>




#### 场景说明<a name="ZH-CN_TOPIC_0000001880628749"></a>

ECC签名验签主要应用场景是私钥签名公钥验签。

#### 工作流程<a name="ZH-CN_TOPIC_0000001833829476"></a>

1.  生成消息对应的hash摘要，调用HASH/HMAC相应接口完成。
2.  私钥签名，调用uapi\_drv\_cipher\_pke\_ecdsa\_sign接口完成。
3.  公钥验签，调用uapi\_drv\_cipher\_pke\_ecdsa\_verify接口完成。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >签名验签所需要的公私钥对可调用uapi\_drv\_cipher\_pke\_ecc\_gen\_key接口生成，可以调用uapi\_drv\_cipher\_pke\_check\_dot\_on\_curve接口以确认公钥确实是曲线上的点，签名需要先计算hash摘要，签名过程是对摘要进行签名。

#### 注意事项<a name="ZH-CN_TOPIC_0000001833669696"></a>

支持 RFC 5639 - Brainpool P256/384/512r1、NIST FIPS 186 - 4 P192/224/256/384/521的私钥签名和公钥验签。

### EDDSA签名验签<a name="ZH-CN_TOPIC_0000001880468977"></a>




#### 场景说明<a name="ZH-CN_TOPIC_0000001880628753"></a>

EDDSA签名验签主要应用场景是私钥签名公钥验签，是使用ed25519这种特殊曲线签名验签。

#### 工作流程<a name="ZH-CN_TOPIC_0000001833829480"></a>

1.  私钥签名，调用uapi\_drv\_cipher\_pke\_eddsa\_sign接口完成。
2.  公钥验签，调用uapi\_drv\_cipher\_pke\_eddsa\_verify接口完成。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >签名验签所需要的公私钥对可调用uapi\_drv\_cipher\_pke\_ecc\_gen\_key接口生成，可以调用uapi\_drv\_cipher\_pke\_check\_dot\_on\_curve接口以确认公钥确实是曲线上的点，EDDSA签名不需要提前计算hash，直接传入消息进行签名即可。

#### 注意事项<a name="ZH-CN_TOPIC_0000001833669700"></a>

支持 RFC 8032 - ED25519的私钥签名和公钥验签。

### 大数运算<a name="ZH-CN_TOPIC_0000001880468981"></a>



#### 场景说明<a name="ZH-CN_TOPIC_0000001880628757"></a>

大数运算主要用于非对称加解密和签名验签的计算过程。

#### 工作流程<a name="ZH-CN_TOPIC_0000001833829484"></a>

直接调用大数计算接口完成相应类型的大数计算即可，例如模加可直接调用uapi\_drv\_cipher\_pke\_add\_mod接口完成。

### ECDH 密钥协商<a name="ZH-CN_TOPIC_0000001833669704"></a>




#### 场景说明<a name="ZH-CN_TOPIC_0000001880468985"></a>

密钥协商主要用于消息传递双方在生成各自的公私钥对之后进行密钥交换。

#### 工作流程<a name="ZH-CN_TOPIC_0000001880628761"></a>

1.  消息传递者a生成自己的公私钥对，调用uapi\_drv\_cipher\_pke\_ecc\_gen\_key接口完成。
2.  消息接收者b生成自己的公私钥对，调用uapi\_drv\_cipher\_pke\_ecc\_gen\_key接口完成。
3.  密钥协商，消息传递者a/消息接收者b使用自己的私钥和对方的公钥生成共享密钥，调用uapi\_drv\_cipher\_pke\_ecc\_gen\_ecdh\_key接口完成。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >-   对于给定的私钥uapi\_drv\_cipher\_pke\_ecc\_gen\_key生成的公钥总是固定的；对于未给定私钥的情况下，uapi\_drv\_cipher\_pke\_ecc\_gen\_key生成的公私钥对是随机的。
    >-   共享密钥生成后，消息传递者双方可对生成的共享密钥做比较，以验证共享密钥的正确性。

#### 注意事项<a name="ZH-CN_TOPIC_0000001833829488"></a>

-   支持RFC 5639 - Brainpool P256/384/512r1、NIST FIPS 186 - 4 P192/224/256/384/521、RFC 7748 - Curve448/Curve25519、RFC 8032 - ED25519（即EDDSA）和SM2的公私钥对生成，及由给定的私钥生成其对应的公钥。
-   支持RFC 5639 - Brainpool P256/384/512r1、NIST FIPS 186 - 4 P192/224/256/384/521、RFC 7748 - Curve448/Curve25519和SM2的密钥交换（ECDH），低于256bit的ECDH及NIST FIPS对应的曲线为不安全算法，不建议使用。

### DH 密钥协商<a name="ZH-CN_TOPIC_0000001833669708"></a>




#### 场景说明<a name="ZH-CN_TOPIC_0000001880468989"></a>

密钥协商主要用于消息传递双方在生成各自的公私钥对之后进行密钥交换，DH密钥协商用于非曲线类型。

#### 工作流程<a name="ZH-CN_TOPIC_0000001880628765"></a>

1.  消息传递者a生成自己的公私钥对，调用uapi\_drv\_cipher\_pke\_dh\_gen\_key接口完成。
2.  消息接收者b生成自己的公私钥对，调用uapi\_drv\_cipher\_pke\_dh\_gen\_key接口完成。
3.  密钥协商，消息传递者a/消息接收者b使用自己的私钥和对方的公钥生成共享密钥，调用uapi\_drv\_cipher\_pke\_dh\_compute\_key接口完成。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >-   对于给定的私钥uapi\_drv\_cipher\_pke\_dh\_gen\_key生成的公钥总是固定的；对于未给定私钥的情况下，uapi\_drv\_cipher\_pke\_dh\_gen\_key生成的公私钥对是随机的。
    >-   共享密钥生成后，消息传递者双方可对生成的共享密钥做比较，以验证共享密钥的正确性。

#### 注意事项<a name="ZH-CN_TOPIC_0000001833829492"></a>

-   支持192/224/256/384/512/521/1024/2048/3072/4096比特DH密钥协商，低于3072bits的DH为不安全算法，不建议使用。

### FLASH在线解密<a name="ZH-CN_TOPIC_0000001833669712"></a>




#### 场景说明<a name="ZH-CN_TOPIC_0000001880468997"></a>

由于运行在CPU上的OS和应用程序，都是加密且运行在FLASH上。所以，安全启动过程中， Boot需要配置OS镜像的FLASH在线解密。该模块主要暴露给boot使用，上层业务不使用。

#### 工作流程<a name="ZH-CN_TOPIC_0000001880628769"></a>

1.  配置要执行在线解密操作的region及其对应flash区域的起始地址，调用drv\_fapc\_set\_config接口完成。
2.  配置在线解密操作使用的iv，调用drv\_fapc\_set\_iv接口完成。
3.  配置在线解密操作使用的key，详见“[密钥配置](密钥配置.md)”小节。
4.  直接读取已配置在线解密操作的flash区域内容，读取结果即为解密之后的结果。

#### 注意事项<a name="ZH-CN_TOPIC_0000001833829496"></a>

FLASH在线解密使用的算法是AES\_128\_CTR，因此在使用该功能时，对应flash区域的加密方式也应是AES\_128\_CTR。

boot配置镜像的FLASH在线解密时，使用的root key类型由对应芯片自行选择。

### 安全相关efuse烧写建议<a name="ZH-CN_TOPIC_0000001833669716"></a>

安全特性相关的efuse位较多，涉及到安全特性的正确使用，此处将逐一列出相关efuse及对应使用场景和烧写建议供参考，各项目根据具体需求及实际efuse排布表单进行合理配置。[表1](#_table1523256143518)是OEM不同场景下使用的efuse，及其建议烧写阶段和建议烧写值。

**表 1**  安全特性efuse使用场景及烧写建议

<a name="_table1523256143518"></a>
<table><thead align="left"><tr id="row1130mcpsimp"><th class="cellrowborder" valign="top" width="17.82178217821782%" id="mcps1.2.6.1.1"><p id="p1132mcpsimp"><a name="p1132mcpsimp"></a><a name="p1132mcpsimp"></a>使用场景</p>
</th>
<th class="cellrowborder" valign="top" width="17.82178217821782%" id="mcps1.2.6.1.2"><p id="p1134mcpsimp"><a name="p1134mcpsimp"></a><a name="p1134mcpsimp"></a>关键项</p>
</th>
<th class="cellrowborder" valign="top" width="11.061106110611062%" id="mcps1.2.6.1.3"><p id="p1136mcpsimp"><a name="p1136mcpsimp"></a><a name="p1136mcpsimp"></a>烧写阶段</p>
</th>
<th class="cellrowborder" valign="top" width="17.581758175817583%" id="mcps1.2.6.1.4"><p id="p1138mcpsimp"><a name="p1138mcpsimp"></a><a name="p1138mcpsimp"></a>烧写完是否需要lock</p>
</th>
<th class="cellrowborder" valign="top" width="35.713571357135706%" id="mcps1.2.6.1.5"><p id="p1140mcpsimp"><a name="p1140mcpsimp"></a><a name="p1140mcpsimp"></a>烧写方式及烧写值</p>
</th>
</tr>
</thead>
<tbody><tr id="row1142mcpsimp"><td class="cellrowborder" rowspan="6" valign="top" width="17.82178217821782%" headers="mcps1.2.6.1.1 "><p id="p1144mcpsimp"><a name="p1144mcpsimp"></a><a name="p1144mcpsimp"></a>安全启动</p>
</td>
<td class="cellrowborder" valign="top" width="17.82178217821782%" headers="mcps1.2.6.1.2 "><p id="p1146mcpsimp"><a name="p1146mcpsimp"></a><a name="p1146mcpsimp"></a>sec_verify_enable</p>
</td>
<td class="cellrowborder" valign="top" width="11.061106110611062%" headers="mcps1.2.6.1.3 "><p id="p1148mcpsimp"><a name="p1148mcpsimp"></a><a name="p1148mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" width="17.581758175817583%" headers="mcps1.2.6.1.4 "><p id="p1150mcpsimp"><a name="p1150mcpsimp"></a><a name="p1150mcpsimp"></a>否</p>
</td>
<td class="cellrowborder" valign="top" width="35.713571357135706%" headers="mcps1.2.6.1.5 "><p id="p1152mcpsimp"><a name="p1152mcpsimp"></a><a name="p1152mcpsimp"></a>Burntool烧写工具，根据是否开启安全启动功能确定。</p>
</td>
</tr>
<tr id="row1153mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.2.6.1.1 "><p id="p1155mcpsimp"><a name="p1155mcpsimp"></a><a name="p1155mcpsimp"></a>mcu_ver</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.2 "><p id="p1157mcpsimp"><a name="p1157mcpsimp"></a><a name="p1157mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.3 "><p id="p1159mcpsimp"><a name="p1159mcpsimp"></a><a name="p1159mcpsimp"></a>否</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.4 "><p id="p1161mcpsimp"><a name="p1161mcpsimp"></a><a name="p1161mcpsimp"></a>若支持防回滚功能，则通过Burntool烧写工具，根据实际情况烧写正确的镜像版本号信息。</p>
</td>
</tr>
<tr id="row1162mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.2.6.1.1 "><p id="p1164mcpsimp"><a name="p1164mcpsimp"></a><a name="p1164mcpsimp"></a>flashboot_ver</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.2 "><p id="p1166mcpsimp"><a name="p1166mcpsimp"></a><a name="p1166mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.3 "><p id="p1168mcpsimp"><a name="p1168mcpsimp"></a><a name="p1168mcpsimp"></a>否</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.4 "><p id="p1170mcpsimp"><a name="p1170mcpsimp"></a><a name="p1170mcpsimp"></a>若支持防回滚功能，则通过Burntool烧写工具，根据实际情况烧写正确的镜像版本号信息。</p>
</td>
</tr>
<tr id="row1171mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.2.6.1.1 "><p id="p1173mcpsimp"><a name="p1173mcpsimp"></a><a name="p1173mcpsimp"></a>params_ver</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.2 "><p id="p1175mcpsimp"><a name="p1175mcpsimp"></a><a name="p1175mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.3 "><p id="p1177mcpsimp"><a name="p1177mcpsimp"></a><a name="p1177mcpsimp"></a>否</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.4 "><p id="p1179mcpsimp"><a name="p1179mcpsimp"></a><a name="p1179mcpsimp"></a>若支持防回滚功能，则通过Burntool烧写工具，根据实际情况烧写正确的镜像版本号信息。</p>
</td>
</tr>
<tr id="row1180mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.2.6.1.1 "><p id="p1182mcpsimp"><a name="p1182mcpsimp"></a><a name="p1182mcpsimp"></a>Hash_root_public_key</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.2 "><p id="p1184mcpsimp"><a name="p1184mcpsimp"></a><a name="p1184mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.3 "><p id="p1186mcpsimp"><a name="p1186mcpsimp"></a><a name="p1186mcpsimp"></a>是</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.4 "><p id="p1188mcpsimp"><a name="p1188mcpsimp"></a><a name="p1188mcpsimp"></a>Burntool烧写工具，根公钥镜像HASH值。</p>
</td>
</tr>
<tr id="row1189mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.2.6.1.1 "><p id="p1191mcpsimp"><a name="p1191mcpsimp"></a><a name="p1191mcpsimp"></a>MSID</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.2 "><p id="p1193mcpsimp"><a name="p1193mcpsimp"></a><a name="p1193mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.3 "><p id="p1195mcpsimp"><a name="p1195mcpsimp"></a><a name="p1195mcpsimp"></a>否</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.4 "><p id="p1197mcpsimp"><a name="p1197mcpsimp"></a><a name="p1197mcpsimp"></a>Burntool烧写工具，市场ID。</p>
</td>
</tr>
<tr id="row1198mcpsimp"><td class="cellrowborder" rowspan="4" valign="top" width="17.82178217821782%" headers="mcps1.2.6.1.1 "><p id="p1200mcpsimp"><a name="p1200mcpsimp"></a><a name="p1200mcpsimp"></a>安全驱动</p>
</td>
<td class="cellrowborder" valign="top" width="17.82178217821782%" headers="mcps1.2.6.1.2 "><p id="p1202mcpsimp"><a name="p1202mcpsimp"></a><a name="p1202mcpsimp"></a>otp_crc_rd_disable（KM）</p>
</td>
<td class="cellrowborder" valign="top" width="11.061106110611062%" headers="mcps1.2.6.1.3 "><p id="p1204mcpsimp"><a name="p1204mcpsimp"></a><a name="p1204mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" width="17.581758175817583%" headers="mcps1.2.6.1.4 "><p id="p1206mcpsimp"><a name="p1206mcpsimp"></a><a name="p1206mcpsimp"></a>否</p>
</td>
<td class="cellrowborder" valign="top" width="35.713571357135706%" headers="mcps1.2.6.1.5 "><p id="p1208mcpsimp"><a name="p1208mcpsimp"></a><a name="p1208mcpsimp"></a>Burntool烧写工具，根据是否保留CRC debug功能确定烧写值。</p>
</td>
</tr>
<tr id="row1209mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.2.6.1.1 "><p id="p1211mcpsimp"><a name="p1211mcpsimp"></a><a name="p1211mcpsimp"></a>sha1_disable</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.2 "><p id="p1213mcpsimp"><a name="p1213mcpsimp"></a><a name="p1213mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.3 "><p id="p1215mcpsimp"><a name="p1215mcpsimp"></a><a name="p1215mcpsimp"></a>否</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.4 "><p id="p1217mcpsimp"><a name="p1217mcpsimp"></a><a name="p1217mcpsimp"></a>Burntool烧写工具，根据是否关闭SHA1来确定。</p>
</td>
</tr>
<tr id="row1218mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.2.6.1.1 "><p id="p1220mcpsimp"><a name="p1220mcpsimp"></a><a name="p1220mcpsimp"></a>rkp_deob_alg_sel</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.2 "><p id="p1222mcpsimp"><a name="p1222mcpsimp"></a><a name="p1222mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.3 "><p id="p1224mcpsimp"><a name="p1224mcpsimp"></a><a name="p1224mcpsimp"></a>否</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.4 "><p id="p1226mcpsimp"><a name="p1226mcpsimp"></a><a name="p1226mcpsimp"></a>Burntool烧写工具，配置DEOB算法。</p>
</td>
</tr>
<tr id="row1227mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.2.6.1.1 "><p id="p1229mcpsimp"><a name="p1229mcpsimp"></a><a name="p1229mcpsimp"></a>sm_disable</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.2 "><p id="p1231mcpsimp"><a name="p1231mcpsimp"></a><a name="p1231mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.3 "><p id="p1233mcpsimp"><a name="p1233mcpsimp"></a><a name="p1233mcpsimp"></a>否</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.4 "><p id="p1235mcpsimp"><a name="p1235mcpsimp"></a><a name="p1235mcpsimp"></a>Burntool烧写工具，根据是否关闭国密来确定。</p>
</td>
</tr>
<tr id="row1236mcpsimp"><td class="cellrowborder" rowspan="2" valign="top" width="17.82178217821782%" headers="mcps1.2.6.1.1 "><p id="p1238mcpsimp"><a name="p1238mcpsimp"></a><a name="p1238mcpsimp"></a>AES/SM4加解密，HMAC</p>
</td>
<td class="cellrowborder" valign="top" width="17.82178217821782%" headers="mcps1.2.6.1.2 "><p id="p1240mcpsimp"><a name="p1240mcpsimp"></a><a name="p1240mcpsimp"></a>obfu_mrk1_owner_id</p>
</td>
<td class="cellrowborder" valign="top" width="11.061106110611062%" headers="mcps1.2.6.1.3 "><p id="p1242mcpsimp"><a name="p1242mcpsimp"></a><a name="p1242mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" width="17.581758175817583%" headers="mcps1.2.6.1.4 "><p id="p1244mcpsimp"><a name="p1244mcpsimp"></a><a name="p1244mcpsimp"></a>否</p>
</td>
<td class="cellrowborder" valign="top" width="35.713571357135706%" headers="mcps1.2.6.1.5 "><p id="p1246mcpsimp"><a name="p1246mcpsimp"></a><a name="p1246mcpsimp"></a>Burntool烧写工具，16bit随机值。</p>
</td>
</tr>
<tr id="row1247mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.2.6.1.1 "><p id="p1249mcpsimp"><a name="p1249mcpsimp"></a><a name="p1249mcpsimp"></a>obfu_mrk</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.2 "><p id="p1251mcpsimp"><a name="p1251mcpsimp"></a><a name="p1251mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.3 "><p id="p1253mcpsimp"><a name="p1253mcpsimp"></a><a name="p1253mcpsimp"></a>否</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.2.6.1.4 "><p id="p1255mcpsimp"><a name="p1255mcpsimp"></a><a name="p1255mcpsimp"></a>Burntool烧写工具，128bit随机值，加解密和HMAC硬件密钥派生。</p>
</td>
</tr>
<tr id="row1256mcpsimp"><td class="cellrowborder" valign="top" width="17.82178217821782%" headers="mcps1.2.6.1.1 "><p id="p1258mcpsimp"><a name="p1258mcpsimp"></a><a name="p1258mcpsimp"></a>安全存储</p>
</td>
<td class="cellrowborder" valign="top" width="17.82178217821782%" headers="mcps1.2.6.1.2 "><p id="p1260mcpsimp"><a name="p1260mcpsimp"></a><a name="p1260mcpsimp"></a>obfu_rusk</p>
</td>
<td class="cellrowborder" valign="top" width="11.061106110611062%" headers="mcps1.2.6.1.3 "><p id="p1262mcpsimp"><a name="p1262mcpsimp"></a><a name="p1262mcpsimp"></a>OEM</p>
</td>
<td class="cellrowborder" valign="top" width="17.581758175817583%" headers="mcps1.2.6.1.4 "><p id="p1264mcpsimp"><a name="p1264mcpsimp"></a><a name="p1264mcpsimp"></a>否</p>
</td>
<td class="cellrowborder" valign="top" width="35.713571357135706%" headers="mcps1.2.6.1.5 "><p id="p1266mcpsimp"><a name="p1266mcpsimp"></a><a name="p1266mcpsimp"></a>Burntool烧写工具，128bit随机值，用于派生安全存储密钥。</p>
</td>
</tr>
</tbody>
</table>

# 错误码<a name="ZH-CN_TOPIC_0000001880469001"></a>

>![](public_sys-resources/icon-note.gif) **说明：** 
>本章描述了CIPHER DRIVER的错误码，便于开发人员理解与定位所发生的错误。


## CIPHER DRIVER 错误码结构与说明<a name="ZH-CN_TOPIC_0000001880628773"></a>

Cipher驱动返回值通常有成功和失败两种类型，如[表1](#_d0e16563)所示。

**表 1**  Cipher驱动返回值

<a name="_d0e16563"></a>
<table><thead align="left"><tr id="row652mcpsimp"><th class="cellrowborder" valign="top" width="48%" id="mcps1.2.3.1.1"><p id="p654mcpsimp"><a name="p654mcpsimp"></a><a name="p654mcpsimp"></a>成员名称</p>
</th>
<th class="cellrowborder" valign="top" width="52%" id="mcps1.2.3.1.2"><p id="p656mcpsimp"><a name="p656mcpsimp"></a><a name="p656mcpsimp"></a>枚举值</p>
</th>
</tr>
</thead>
<tbody><tr id="row658mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.2.3.1.1 "><p id="p660mcpsimp"><a name="p660mcpsimp"></a><a name="p660mcpsimp"></a>CRYPTO_SUCCESS</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.2.3.1.2 "><p id="p662mcpsimp"><a name="p662mcpsimp"></a><a name="p662mcpsimp"></a>0</p>
</td>
</tr>
<tr id="row663mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.2.3.1.1 "><p id="p665mcpsimp"><a name="p665mcpsimp"></a><a name="p665mcpsimp"></a>CRYPTO_FAILURE</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.2.3.1.2 "><p id="p667mcpsimp"><a name="p667mcpsimp"></a><a name="p667mcpsimp"></a>0xFFFFFFFF</p>
</td>
</tr>
</tbody>
</table>

为了通过错误码更加清晰的标识错误发生的具体信息，采用了层级结构信息拼接。其结构为：

Env\(4 bits\) | Layer\(4 bits\) | Modules\(4 bits\) | Reserved\(12 bits\) | Error Code\(8 bits\)





### ENV<a name="ZH-CN_TOPIC_0000001833829500"></a>

【描述】

错误码发生的操作系统环境。

【定义】

```
#define ERROR_ENV_LINUX         0x1 
#define ERROR_ENV_ITRUSTEE      0x2 
#define ERROR_ENV_OPTEE         0x3 
#define ERROR_ENV_LITEOS        0x4 
#define ERROR_ENV_SELITEOS      0x5 
#define ERROR_ENV_NOOS          0x6 
```

【成员】

<a name="table1292mcpsimp"></a>
<table><thead align="left"><tr id="row1297mcpsimp"><th class="cellrowborder" valign="top" width="48%" id="mcps1.1.3.1.1"><p id="p1299mcpsimp"><a name="p1299mcpsimp"></a><a name="p1299mcpsimp"></a>成员名称</p>
</th>
<th class="cellrowborder" valign="top" width="52%" id="mcps1.1.3.1.2"><p id="p1301mcpsimp"><a name="p1301mcpsimp"></a><a name="p1301mcpsimp"></a>枚举值</p>
</th>
</tr>
</thead>
<tbody><tr id="row1303mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p1305mcpsimp"><a name="p1305mcpsimp"></a><a name="p1305mcpsimp"></a>ERROR_ENV_LINUX</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p1307mcpsimp"><a name="p1307mcpsimp"></a><a name="p1307mcpsimp"></a>LINUX</p>
</td>
</tr>
<tr id="row1308mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p1310mcpsimp"><a name="p1310mcpsimp"></a><a name="p1310mcpsimp"></a>ERROR_ENV_ITRUSTEE</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p1312mcpsimp"><a name="p1312mcpsimp"></a><a name="p1312mcpsimp"></a>ITRUSTEE</p>
</td>
</tr>
<tr id="row1313mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p1315mcpsimp"><a name="p1315mcpsimp"></a><a name="p1315mcpsimp"></a>ERROR_ENV_OPTEE</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p1317mcpsimp"><a name="p1317mcpsimp"></a><a name="p1317mcpsimp"></a>OPTEE</p>
</td>
</tr>
<tr id="row1318mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p1320mcpsimp"><a name="p1320mcpsimp"></a><a name="p1320mcpsimp"></a>ERROR_ENV_LITEOS</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p1322mcpsimp"><a name="p1322mcpsimp"></a><a name="p1322mcpsimp"></a>LITEOS</p>
</td>
</tr>
<tr id="row1323mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p1325mcpsimp"><a name="p1325mcpsimp"></a><a name="p1325mcpsimp"></a>ERROR_ENV_SELITEOS</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p1327mcpsimp"><a name="p1327mcpsimp"></a><a name="p1327mcpsimp"></a>SELITEOS</p>
</td>
</tr>
<tr id="row1328mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p1330mcpsimp"><a name="p1330mcpsimp"></a><a name="p1330mcpsimp"></a>ERROR_ENV_NOOS</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p1332mcpsimp"><a name="p1332mcpsimp"></a><a name="p1332mcpsimp"></a>无OS环境</p>
</td>
</tr>
</tbody>
</table>

【注意】

无

### LAYER<a name="ZH-CN_TOPIC_0000001833669720"></a>

【描述】

错误码发生的代码层级。

【定义】

```
enum { 
    ERROR_LAYER_UAPI = 0x1, 
    ERROR_LAYER_DISPATCH, 
    ERROR_LAYER_KAPI, 
    ERROR_LAYER_DRV, 
    ERROR_LAYER_HAL, 
};
```

【成员】

<a name="table1043mcpsimp"></a>
<table><thead align="left"><tr id="row1048mcpsimp"><th class="cellrowborder" valign="top" width="48%" id="mcps1.1.3.1.1"><p id="p1050mcpsimp"><a name="p1050mcpsimp"></a><a name="p1050mcpsimp"></a>成员名称</p>
</th>
<th class="cellrowborder" valign="top" width="52%" id="mcps1.1.3.1.2"><p id="p1052mcpsimp"><a name="p1052mcpsimp"></a><a name="p1052mcpsimp"></a>枚举值</p>
</th>
</tr>
</thead>
<tbody><tr id="row1054mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p1056mcpsimp"><a name="p1056mcpsimp"></a><a name="p1056mcpsimp"></a>ERROR_LAYER_UAPI</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p1058mcpsimp"><a name="p1058mcpsimp"></a><a name="p1058mcpsimp"></a>用户接口层</p>
</td>
</tr>
<tr id="row1059mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p1061mcpsimp"><a name="p1061mcpsimp"></a><a name="p1061mcpsimp"></a>ERROR_LAYER_DISPATCH</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p1063mcpsimp"><a name="p1063mcpsimp"></a><a name="p1063mcpsimp"></a>指令分发层</p>
</td>
</tr>
<tr id="row1064mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p1066mcpsimp"><a name="p1066mcpsimp"></a><a name="p1066mcpsimp"></a>ERROR_LAYER_KAPI</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p1068mcpsimp"><a name="p1068mcpsimp"></a><a name="p1068mcpsimp"></a>内核接口层</p>
</td>
</tr>
<tr id="row1069mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p1071mcpsimp"><a name="p1071mcpsimp"></a><a name="p1071mcpsimp"></a>ERROR_LAYER_DRV</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p1073mcpsimp"><a name="p1073mcpsimp"></a><a name="p1073mcpsimp"></a>驱动逻辑层</p>
</td>
</tr>
<tr id="row1074mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p1076mcpsimp"><a name="p1076mcpsimp"></a><a name="p1076mcpsimp"></a>ERROR_LAYER_HAL</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p1078mcpsimp"><a name="p1078mcpsimp"></a><a name="p1078mcpsimp"></a>硬件适配层</p>
</td>
</tr>
</tbody>
</table>

【注意】

无

### MODULE<a name="ZH-CN_TOPIC_0000001880469005"></a>

【描述】

错误码发生的CIPHER模块。

【定义】

```
enum { 
    ERROR_MODULE_SYMC = 0x1, 
    ERROR_MODULE_HASH, 
    ERROR_MODULE_PKE, 
    ERROR_MODULE_TRNG, 
    ERROR_MODULE_OTHER 
};
```

【成员】

<a name="table228mcpsimp"></a>
<table><thead align="left"><tr id="row233mcpsimp"><th class="cellrowborder" valign="top" width="48%" id="mcps1.1.3.1.1"><p id="p235mcpsimp"><a name="p235mcpsimp"></a><a name="p235mcpsimp"></a>成员名称</p>
</th>
<th class="cellrowborder" valign="top" width="52%" id="mcps1.1.3.1.2"><p id="p237mcpsimp"><a name="p237mcpsimp"></a><a name="p237mcpsimp"></a>枚举值</p>
</th>
</tr>
</thead>
<tbody><tr id="row239mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p241mcpsimp"><a name="p241mcpsimp"></a><a name="p241mcpsimp"></a>ERROR_MODULE_SYMC</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p243mcpsimp"><a name="p243mcpsimp"></a><a name="p243mcpsimp"></a>对称加解密模块</p>
</td>
</tr>
<tr id="row244mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p246mcpsimp"><a name="p246mcpsimp"></a><a name="p246mcpsimp"></a>ERROR_MODULE_HASH</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p248mcpsimp"><a name="p248mcpsimp"></a><a name="p248mcpsimp"></a>摘要算法模块</p>
</td>
</tr>
<tr id="row249mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p251mcpsimp"><a name="p251mcpsimp"></a><a name="p251mcpsimp"></a>ERROR_MODULE_PKE</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p253mcpsimp"><a name="p253mcpsimp"></a><a name="p253mcpsimp"></a>非对称加解密模块</p>
</td>
</tr>
<tr id="row254mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p256mcpsimp"><a name="p256mcpsimp"></a><a name="p256mcpsimp"></a>ERROR_MODULE_TRNG</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p258mcpsimp"><a name="p258mcpsimp"></a><a name="p258mcpsimp"></a>随机数模块</p>
</td>
</tr>
<tr id="row259mcpsimp"><td class="cellrowborder" valign="top" width="48%" headers="mcps1.1.3.1.1 "><p id="p261mcpsimp"><a name="p261mcpsimp"></a><a name="p261mcpsimp"></a>ERROR_MODULE_OTHER</p>
</td>
<td class="cellrowborder" valign="top" width="52%" headers="mcps1.1.3.1.2 "><p id="p263mcpsimp"><a name="p263mcpsimp"></a><a name="p263mcpsimp"></a>其他模块</p>
</td>
</tr>
</tbody>
</table>

【注意】

无

### 错误类型<a name="ZH-CN_TOPIC_0000001880628777"></a>

【描述】

错误码发生的具体错误类型。

【定义】

```
/* Common Error Code. 0x00 ~ 0x3F. */
ERROR_INVALID_PARAM = 0x0,      /* return when the input param's value is not in the valid range. */
ERROR_PARAM_IS_NULL,            /* return when the input param is NULL and required not NULL. */
ERROR_NOT_INIT,                 /* return when call other functions before call init function. */
ERROR_UNSUPPORT,                /* return when some configuration is unsupport. */
ERROR_UNEXPECTED,               /* reture when unexpected error occurs. */
ERROR_CHN_BUSY,                 /* return when try to create one channel but all channels are busy. */
ERROR_CTX_CLOSED,               /* return when using one ctx to do something but has been closed. */
ERROR_NOT_SET_CONFIG,           /* return when not set_config but need for symc. */
ERROR_NOT_ATTACHED,             /* return when not attach but need for symc. */
ERROR_NOT_MAC_START,            /* return when not mac_start but need for symc. */
ERROR_INVALID_HANDLE,           /* return when pass one invalid handle. */
ERROR_GET_PHYS_ADDR,            /* return when transfer from virt_addr to phys_addr failed. */
ERROR_SYMC_LEN_NOT_ALIGNED,     /* return when length isn't aligned to 16-Byte except CTR/CCM/GCM.  */
ERROR_SYMC_ADDR_NOT_ALIGNED,    /* return when the phys_addr writing to register is not aligned to 4-Byte. */
ERROR_PKE_RSA_SAME_DATA,        /* return when rsa exp_mod, the input is equal to output. */
ERROR_PKE_RSA_CRYPTO_V15_CHECK, /* return when rsa crypto v15 padding check failed. */
ERROR_PKE_RSA_CRYPTO_OAEP_CHECK,    /* return when rsa crypto oaep padding check failed. */
ERROR_PKE_RSA_VERIFY_V15_CHECK,     /* return when rsa verify v15 padding check failed. */
ERROR_PKE_RSA_VERIFY_PSS_CHECK,     /* return when rsa verify pss padding check failed. */
ERROR_PKE_RSA_GEN_KEY,          /* return when rsa generate key failed. */
ERROR_PKE_ECDSA_VERIFY_CHECK,   /* return when ecdsa verify check failed. */
/* Outer's Error Code. 0x40 ~ 0x5F. */
ERROR_MEMCPY_S      = 0x40,     /* return when call memcpy_s failed. */
ERROR_MALLOC,                   /* return when call xxx_malloc failed. */
ERROR_MUTEX_INIT,               /* return when call xxx_mutex_init failed. */
ERROR_MUTEX_LOCK,               /* return when call xxx_lock failed. */
/* Specific Error Code for UAPI. 0x60 ~ 0x6F. */
ERROR_DEV_OPEN_FAILED,          /* return when open dev failed. */
ERROR_COUNT_OVERFLOW,           /* return when call init too many times. */
/* Specific Error Code for Dispatch. 0x70 ~ 0x7F. */
ERROR_CMD_DISMATCH  = 0x70,     /* return when cmd is dismatched. */
ERROR_COPY_FROM_USER,           /* return when call copy_from_user failed. */
ERROR_COPY_TO_USER,             /* return when call copy_to_user failed. */
ERROR_MEM_HANDLE_GET,           /* return when parse user's mem handle to kernel's mem handle failed. */
ERROR_GET_OWNER,                /* return when call crypto_get_owner failed. */
/* Specific Error Code for KAPI. 0x80 ~ 0x8F. */
ERROR_PROCESS_NOT_INIT = 0x80,  /* return when one process not call kapi_xxx_init first. */
ERROR_MAX_PROCESS,              /* return when process's num is over the limit. */
ERROR_MEMORY_ACCESS,            /* return when access the memory that does not belong to itself.  */
ERROR_INVALID_PROCESS,          /* return when the process accesses resources of other processes. */
/* Specific Error Code for DRV. 0x90 ~ 0x9F. */
/* Specific Error Code for HAL. 0xA0 ~ 0xAF. */
ERROR_HASH_LOGIC    = 0xA0,     /* return when hash logic's error occurs. */
ERROR_PKE_LOGIC,                /* return when pke logic's error occurs. */
ERROR_INVALID_CPU_TYPE,         /* return when logic get the invalid cpu type. */
ERROR_INVALID_REGISTER_VALUE,   /* return when value in register is invalid. */
ERROR_INVALID_PHYS_ADDR,        /* return when phys_addr is invalid. */
/* Specific Error Code for Timeout. 0xB0 ~ 0xBF. */
ERROR_GET_TRNG_TIMEOUT = 0xB0,  /* return when logic get rnd timeout. */
ERROR_HASH_CLEAR_CHN_TIMEOUT,   /* return when clear hash channel timeout. */
ERROR_HASH_CALC_TIMEOUT,        /* return when hash calculation timeout. */
ERROR_SYMC_CLEAR_CHN_TIMEOUT,   /* return when clear symc channel timeout. */
ERROR_SYMC_CALC_TIMEOUT,        /* return when symc crypto timeout. */
ERROR_SYMC_GET_TAG_TIMEOUT,     /* return when symc get tag timeout. */
ERROR_PKE_LOCK_TIMEOUT,         /* return when pke lock timeout. */
ERROR_PKE_WAIT_DONE_TIMEOUT,    /* return when pke wait done timeout. */
ERROR_PKE_ROBUST_WARNING,    /* return when pke get robust warning. */
```

【成员】

<a name="table733mcpsimp"></a>
<table><thead align="left"><tr id="row739mcpsimp"><th class="cellrowborder" valign="top" id="mcps1.1.4.1.1"><p id="p741mcpsimp"><a name="p741mcpsimp"></a><a name="p741mcpsimp"></a>类型</p>
</th>
<th class="cellrowborder" colspan="2" valign="top" id="mcps1.1.4.1.2"><p id="p743mcpsimp"><a name="p743mcpsimp"></a><a name="p743mcpsimp"></a>描述</p>
</th>
</tr>
</thead>
<tbody><tr id="row745mcpsimp"><td class="cellrowborder" rowspan="21" valign="top" width="28.000000000000004%" headers="mcps1.1.4.1.1 "><p id="p747mcpsimp"><a name="p747mcpsimp"></a><a name="p747mcpsimp"></a>COMMON</p>
</td>
<td class="cellrowborder" valign="top" width="38%" headers="mcps1.1.4.1.2 "><p id="p749mcpsimp"><a name="p749mcpsimp"></a><a name="p749mcpsimp"></a>ERROR_INVALID_PARAM</p>
</td>
<td class="cellrowborder" valign="top" width="34%" headers="mcps1.1.4.1.2 "><p id="p751mcpsimp"><a name="p751mcpsimp"></a><a name="p751mcpsimp"></a>输入参数在无效范围</p>
</td>
</tr>
<tr id="row752mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p754mcpsimp"><a name="p754mcpsimp"></a><a name="p754mcpsimp"></a>ERROR_PARAM_IS_NULL</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p756mcpsimp"><a name="p756mcpsimp"></a><a name="p756mcpsimp"></a>输入非法空指针参数</p>
</td>
</tr>
<tr id="row757mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p759mcpsimp"><a name="p759mcpsimp"></a><a name="p759mcpsimp"></a>ERROR_NOT_INIT</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p761mcpsimp"><a name="p761mcpsimp"></a><a name="p761mcpsimp"></a>未调用初始化函数</p>
</td>
</tr>
<tr id="row762mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p764mcpsimp"><a name="p764mcpsimp"></a><a name="p764mcpsimp"></a>ERROR_UNSUPPORT</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p766mcpsimp"><a name="p766mcpsimp"></a><a name="p766mcpsimp"></a>算法或配置未支持</p>
</td>
</tr>
<tr id="row767mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p769mcpsimp"><a name="p769mcpsimp"></a><a name="p769mcpsimp"></a>ERROR_UNEXPECTED</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p771mcpsimp"><a name="p771mcpsimp"></a><a name="p771mcpsimp"></a>预期之外的错误</p>
</td>
</tr>
<tr id="row772mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p774mcpsimp"><a name="p774mcpsimp"></a><a name="p774mcpsimp"></a>ERROR_CHN_BUSY</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p776mcpsimp"><a name="p776mcpsimp"></a><a name="p776mcpsimp"></a>通道均被占用时尝试创建通道</p>
</td>
</tr>
<tr id="row777mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p779mcpsimp"><a name="p779mcpsimp"></a><a name="p779mcpsimp"></a>ERROR_CTX_CLOSED</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p781mcpsimp"><a name="p781mcpsimp"></a><a name="p781mcpsimp"></a>尝试使用已关闭的CTX</p>
</td>
</tr>
<tr id="row782mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p784mcpsimp"><a name="p784mcpsimp"></a><a name="p784mcpsimp"></a>ERROR_NOT_SET_CONFIG</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p786mcpsimp"><a name="p786mcpsimp"></a><a name="p786mcpsimp"></a>SYMC未调用set_config函数</p>
</td>
</tr>
<tr id="row787mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p789mcpsimp"><a name="p789mcpsimp"></a><a name="p789mcpsimp"></a>ERROR_NOT_ATTACHED</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p791mcpsimp"><a name="p791mcpsimp"></a><a name="p791mcpsimp"></a>SYMC未绑定KEYSLOT</p>
</td>
</tr>
<tr id="row792mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p794mcpsimp"><a name="p794mcpsimp"></a><a name="p794mcpsimp"></a>ERROR_NOT_MAC_START</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p796mcpsimp"><a name="p796mcpsimp"></a><a name="p796mcpsimp"></a>SYMC未调用mac_start函数</p>
</td>
</tr>
<tr id="row797mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p799mcpsimp"><a name="p799mcpsimp"></a><a name="p799mcpsimp"></a>ERROR_INVALID_HANDLE</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p801mcpsimp"><a name="p801mcpsimp"></a><a name="p801mcpsimp"></a>传入了无效的handle</p>
</td>
</tr>
<tr id="row802mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p804mcpsimp"><a name="p804mcpsimp"></a><a name="p804mcpsimp"></a>ERROR_GET_PHYS_ADDR</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p806mcpsimp"><a name="p806mcpsimp"></a><a name="p806mcpsimp"></a>获取物理地址失败</p>
</td>
</tr>
<tr id="row807mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p809mcpsimp"><a name="p809mcpsimp"></a><a name="p809mcpsimp"></a>ERROR_SYMC_LEN_NOT_ALIGNED</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p811mcpsimp"><a name="p811mcpsimp"></a><a name="p811mcpsimp"></a>SYMC长度未对其到16Byte除了（CTR/CCM/GCM）模式</p>
</td>
</tr>
<tr id="row812mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p814mcpsimp"><a name="p814mcpsimp"></a><a name="p814mcpsimp"></a>ERROR_SYMC_ADDR_NOT_ALIGNED</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p816mcpsimp"><a name="p816mcpsimp"></a><a name="p816mcpsimp"></a>SYMC写到寄存器的物理地址没有按照4Byte对齐</p>
</td>
</tr>
<tr id="row817mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p819mcpsimp"><a name="p819mcpsimp"></a><a name="p819mcpsimp"></a>ERROR_PKE_RSA_SAME_DATA</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p821mcpsimp"><a name="p821mcpsimp"></a><a name="p821mcpsimp"></a>RSA模密运算时，输入和输出相等</p>
</td>
</tr>
<tr id="row822mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p824mcpsimp"><a name="p824mcpsimp"></a><a name="p824mcpsimp"></a>ERROR_PKE_RSA_CRYPTO_V15_CHECK</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p826mcpsimp"><a name="p826mcpsimp"></a><a name="p826mcpsimp"></a>RSA PKCSV15 解密 Padding校验失败</p>
</td>
</tr>
<tr id="row827mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p829mcpsimp"><a name="p829mcpsimp"></a><a name="p829mcpsimp"></a>ERROR_PKE_RSA_CRYPTO_OAEP_CHECK</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p831mcpsimp"><a name="p831mcpsimp"></a><a name="p831mcpsimp"></a>RSA OAEP 解密 Padding校验失败</p>
</td>
</tr>
<tr id="row832mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p834mcpsimp"><a name="p834mcpsimp"></a><a name="p834mcpsimp"></a>ERROR_PKE_RSA_VERIFY_V15_CHECK</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p836mcpsimp"><a name="p836mcpsimp"></a><a name="p836mcpsimp"></a>RSA PKCSV15 验签 Padding校验失败</p>
</td>
</tr>
<tr id="row837mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p839mcpsimp"><a name="p839mcpsimp"></a><a name="p839mcpsimp"></a>ERROR_PKE_RSA_VERIFY_PSS_CHECK</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p841mcpsimp"><a name="p841mcpsimp"></a><a name="p841mcpsimp"></a>RSA PSS 验签 Padding校验失败</p>
</td>
</tr>
<tr id="row842mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p844mcpsimp"><a name="p844mcpsimp"></a><a name="p844mcpsimp"></a>ERROR_PKE_RSA_GEN_KEY</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p846mcpsimp"><a name="p846mcpsimp"></a><a name="p846mcpsimp"></a>RSA 密钥生成失败</p>
<p id="p847mcpsimp"><a name="p847mcpsimp"></a><a name="p847mcpsimp"></a>该功能暂不支持</p>
</td>
</tr>
<tr id="row848mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p850mcpsimp"><a name="p850mcpsimp"></a><a name="p850mcpsimp"></a>ERROR_PKE_ECDSA_VERIFY_CHECK</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p852mcpsimp"><a name="p852mcpsimp"></a><a name="p852mcpsimp"></a>ECDSA 验签失败</p>
</td>
</tr>
<tr id="row853mcpsimp"><td class="cellrowborder" rowspan="4" valign="top" width="28.000000000000004%" headers="mcps1.1.4.1.1 "><p id="p855mcpsimp"><a name="p855mcpsimp"></a><a name="p855mcpsimp"></a>OUTER</p>
</td>
<td class="cellrowborder" valign="top" width="38%" headers="mcps1.1.4.1.2 "><p id="p857mcpsimp"><a name="p857mcpsimp"></a><a name="p857mcpsimp"></a>ERROR_MEMCPY_S</p>
</td>
<td class="cellrowborder" valign="top" width="34%" headers="mcps1.1.4.1.2 "><p id="p859mcpsimp"><a name="p859mcpsimp"></a><a name="p859mcpsimp"></a>调用memcpy_s失败</p>
</td>
</tr>
<tr id="row860mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p862mcpsimp"><a name="p862mcpsimp"></a><a name="p862mcpsimp"></a>ERROR_MALLOC</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p864mcpsimp"><a name="p864mcpsimp"></a><a name="p864mcpsimp"></a>调用xxx_malloc失败</p>
</td>
</tr>
<tr id="row865mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p867mcpsimp"><a name="p867mcpsimp"></a><a name="p867mcpsimp"></a>ERROR_MUTEX_INIT</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p869mcpsimp"><a name="p869mcpsimp"></a><a name="p869mcpsimp"></a>调用xxx_mutex_init失败</p>
</td>
</tr>
<tr id="row870mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p872mcpsimp"><a name="p872mcpsimp"></a><a name="p872mcpsimp"></a>ERROR_MUTEX_LOCK</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p874mcpsimp"><a name="p874mcpsimp"></a><a name="p874mcpsimp"></a>调用xxx_lock失败</p>
</td>
</tr>
<tr id="row875mcpsimp"><td class="cellrowborder" rowspan="2" valign="top" width="28.000000000000004%" headers="mcps1.1.4.1.1 "><p id="p877mcpsimp"><a name="p877mcpsimp"></a><a name="p877mcpsimp"></a>SPECIFIC UAPI</p>
</td>
<td class="cellrowborder" valign="top" width="38%" headers="mcps1.1.4.1.2 "><p id="p879mcpsimp"><a name="p879mcpsimp"></a><a name="p879mcpsimp"></a>ERROR_DEV_OPEN_FAILED</p>
</td>
<td class="cellrowborder" valign="top" width="34%" headers="mcps1.1.4.1.2 "><p id="p881mcpsimp"><a name="p881mcpsimp"></a><a name="p881mcpsimp"></a>打开设备失败</p>
</td>
</tr>
<tr id="row882mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p884mcpsimp"><a name="p884mcpsimp"></a><a name="p884mcpsimp"></a>ERROR_COUNT_OVERFLOW</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p886mcpsimp"><a name="p886mcpsimp"></a><a name="p886mcpsimp"></a>调用太多次初始化</p>
</td>
</tr>
<tr id="row887mcpsimp"><td class="cellrowborder" rowspan="5" valign="top" width="28.000000000000004%" headers="mcps1.1.4.1.1 "><p id="p889mcpsimp"><a name="p889mcpsimp"></a><a name="p889mcpsimp"></a>SPECIFIC DISPATCH</p>
</td>
<td class="cellrowborder" valign="top" width="38%" headers="mcps1.1.4.1.2 "><p id="p891mcpsimp"><a name="p891mcpsimp"></a><a name="p891mcpsimp"></a>ERROR_CMD_DISMATCHED</p>
</td>
<td class="cellrowborder" valign="top" width="34%" headers="mcps1.1.4.1.2 "><p id="p893mcpsimp"><a name="p893mcpsimp"></a><a name="p893mcpsimp"></a>CMD无匹配项</p>
</td>
</tr>
<tr id="row894mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p896mcpsimp"><a name="p896mcpsimp"></a><a name="p896mcpsimp"></a>ERROR_COPY_FROM_USER</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p898mcpsimp"><a name="p898mcpsimp"></a><a name="p898mcpsimp"></a>从用户态拷贝发生错误</p>
</td>
</tr>
<tr id="row899mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p901mcpsimp"><a name="p901mcpsimp"></a><a name="p901mcpsimp"></a>ERROR_COPY_TO_USER</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p903mcpsimp"><a name="p903mcpsimp"></a><a name="p903mcpsimp"></a>向用户态拷贝发生错误</p>
</td>
</tr>
<tr id="row904mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p906mcpsimp"><a name="p906mcpsimp"></a><a name="p906mcpsimp"></a>ERROR_MEM_HANDLE_GET</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p908mcpsimp"><a name="p908mcpsimp"></a><a name="p908mcpsimp"></a>获取句柄发生错误</p>
</td>
</tr>
<tr id="row909mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p911mcpsimp"><a name="p911mcpsimp"></a><a name="p911mcpsimp"></a>ERROR_GET_OWNER</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p913mcpsimp"><a name="p913mcpsimp"></a><a name="p913mcpsimp"></a>获取使用者发生错误</p>
</td>
</tr>
<tr id="row914mcpsimp"><td class="cellrowborder" rowspan="4" valign="top" width="28.000000000000004%" headers="mcps1.1.4.1.1 "><p id="p916mcpsimp"><a name="p916mcpsimp"></a><a name="p916mcpsimp"></a>SPECIFIC KAPI</p>
</td>
<td class="cellrowborder" valign="top" width="38%" headers="mcps1.1.4.1.2 "><p id="p918mcpsimp"><a name="p918mcpsimp"></a><a name="p918mcpsimp"></a>ERROR_PROCESS_NOT_INIT</p>
</td>
<td class="cellrowborder" valign="top" width="34%" headers="mcps1.1.4.1.2 "><p id="p920mcpsimp"><a name="p920mcpsimp"></a><a name="p920mcpsimp"></a>进程未初始化</p>
</td>
</tr>
<tr id="row921mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p923mcpsimp"><a name="p923mcpsimp"></a><a name="p923mcpsimp"></a>ERROR_MAX_PROCESS</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p925mcpsimp"><a name="p925mcpsimp"></a><a name="p925mcpsimp"></a>数值超过了最大值</p>
</td>
</tr>
<tr id="row926mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p928mcpsimp"><a name="p928mcpsimp"></a><a name="p928mcpsimp"></a>ERROR_MEMORY_ACCESS</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p930mcpsimp"><a name="p930mcpsimp"></a><a name="p930mcpsimp"></a>没有该内存的访问权限</p>
</td>
</tr>
<tr id="row931mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p933mcpsimp"><a name="p933mcpsimp"></a><a name="p933mcpsimp"></a>ERROR_INVALID_PROCESS</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p935mcpsimp"><a name="p935mcpsimp"></a><a name="p935mcpsimp"></a>没有访问资源权限的进程访问了该资源</p>
</td>
</tr>
<tr id="row936mcpsimp"><td class="cellrowborder" rowspan="5" valign="top" width="28.000000000000004%" headers="mcps1.1.4.1.1 "><p id="p938mcpsimp"><a name="p938mcpsimp"></a><a name="p938mcpsimp"></a>SPECIFIC HAL</p>
</td>
<td class="cellrowborder" valign="top" width="38%" headers="mcps1.1.4.1.2 "><p id="p940mcpsimp"><a name="p940mcpsimp"></a><a name="p940mcpsimp"></a>ERROR_HASH_LOGIC</p>
</td>
<td class="cellrowborder" valign="top" width="34%" headers="mcps1.1.4.1.2 "><p id="p942mcpsimp"><a name="p942mcpsimp"></a><a name="p942mcpsimp"></a>HASH发生硬件逻辑错误</p>
</td>
</tr>
<tr id="row943mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p945mcpsimp"><a name="p945mcpsimp"></a><a name="p945mcpsimp"></a>ERROR_PKE_LOGIC</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p947mcpsimp"><a name="p947mcpsimp"></a><a name="p947mcpsimp"></a>PKE发生硬件逻辑错误</p>
</td>
</tr>
<tr id="row948mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p950mcpsimp"><a name="p950mcpsimp"></a><a name="p950mcpsimp"></a>ERROR_INVALID_CPU_TYPE</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p952mcpsimp"><a name="p952mcpsimp"></a><a name="p952mcpsimp"></a>逻辑拿到了无效的CPU类型</p>
</td>
</tr>
<tr id="row953mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p955mcpsimp"><a name="p955mcpsimp"></a><a name="p955mcpsimp"></a>ERROR_INVALID_REGISTER_VALUE</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p957mcpsimp"><a name="p957mcpsimp"></a><a name="p957mcpsimp"></a>寄存器中的值是无效的</p>
</td>
</tr>
<tr id="row958mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p960mcpsimp"><a name="p960mcpsimp"></a><a name="p960mcpsimp"></a>ERROR_INVALID_PHYS_ADDR</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p962mcpsimp"><a name="p962mcpsimp"></a><a name="p962mcpsimp"></a>无效的物理地址</p>
</td>
</tr>
<tr id="row963mcpsimp"><td class="cellrowborder" rowspan="9" valign="top" width="28.000000000000004%" headers="mcps1.1.4.1.1 "><p id="p965mcpsimp"><a name="p965mcpsimp"></a><a name="p965mcpsimp"></a>TIMEOUT</p>
</td>
<td class="cellrowborder" valign="top" width="38%" headers="mcps1.1.4.1.2 "><p id="p967mcpsimp"><a name="p967mcpsimp"></a><a name="p967mcpsimp"></a>ERROR_GET_TRNG_TIMEOUT</p>
</td>
<td class="cellrowborder" valign="top" width="34%" headers="mcps1.1.4.1.2 "><p id="p969mcpsimp"><a name="p969mcpsimp"></a><a name="p969mcpsimp"></a>获取随机数超时</p>
</td>
</tr>
<tr id="row970mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p972mcpsimp"><a name="p972mcpsimp"></a><a name="p972mcpsimp"></a>ERROR_HASH_CLEAR_CHN_TIMEOUT</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p974mcpsimp"><a name="p974mcpsimp"></a><a name="p974mcpsimp"></a>HASH清通道超时</p>
</td>
</tr>
<tr id="row975mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p977mcpsimp"><a name="p977mcpsimp"></a><a name="p977mcpsimp"></a>ERROR_HASH_CALC_TIMEOUT</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p979mcpsimp"><a name="p979mcpsimp"></a><a name="p979mcpsimp"></a>HASH计算超时</p>
</td>
</tr>
<tr id="row980mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p982mcpsimp"><a name="p982mcpsimp"></a><a name="p982mcpsimp"></a>ERROR_SYMC_CLEAR_CHN_TIMEOUT</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p984mcpsimp"><a name="p984mcpsimp"></a><a name="p984mcpsimp"></a>SYMC清通道超时</p>
</td>
</tr>
<tr id="row985mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p987mcpsimp"><a name="p987mcpsimp"></a><a name="p987mcpsimp"></a>ERROR_SYMC_CALC_TIMEOUT</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p989mcpsimp"><a name="p989mcpsimp"></a><a name="p989mcpsimp"></a>SYMC计算超时</p>
</td>
</tr>
<tr id="row990mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p992mcpsimp"><a name="p992mcpsimp"></a><a name="p992mcpsimp"></a>ERROR_SYMC_GET_TAG_TIMEOUT</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p994mcpsimp"><a name="p994mcpsimp"></a><a name="p994mcpsimp"></a>获取tag值超时</p>
</td>
</tr>
<tr id="row995mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p997mcpsimp"><a name="p997mcpsimp"></a><a name="p997mcpsimp"></a>ERROR_PKE_LOCK_TIMEOUT</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p999mcpsimp"><a name="p999mcpsimp"></a><a name="p999mcpsimp"></a>PKE锁超时</p>
</td>
</tr>
<tr id="row1000mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p1002mcpsimp"><a name="p1002mcpsimp"></a><a name="p1002mcpsimp"></a>ERROR_PKE_WAIT_DONE_TIMEOUT</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p1004mcpsimp"><a name="p1004mcpsimp"></a><a name="p1004mcpsimp"></a>PKE计算超时</p>
</td>
</tr>
<tr id="row1005mcpsimp"><td class="cellrowborder" valign="top" headers="mcps1.1.4.1.1 "><p id="p1007mcpsimp"><a name="p1007mcpsimp"></a><a name="p1007mcpsimp"></a>ERROR_PKE_ROBUST_WARNING</p>
</td>
<td class="cellrowborder" valign="top" headers="mcps1.1.4.1.2 "><p id="p1009mcpsimp"><a name="p1009mcpsimp"></a><a name="p1009mcpsimp"></a>PKE鲁棒性告警</p>
</td>
</tr>
</tbody>
</table>

>![](public_sys-resources/icon-note.gif) **说明：** 
>security\_unified对错误码进行了层级设计，方便debug时快速定位。用户调用service层接口时返回的错误的错误码不带层级信息，其错误含义与上述表格中的错误码一一对应，具体参见API手册security\_unified模块错误码相关定义，错误码段为0x80001500\~0x8001600.

# 网络安全注意事项<a name="ZH-CN_TOPIC_0000001833829504"></a>



## 安全驱动<a name="ZH-CN_TOPIC_0000001833669724"></a>

-   Cipher驱动实现了标准的对称加密AES/ SM4算法，非对称RSA、ECDSA/SM2/ED25519算法，摘要算法SHA/SM3/HMAC\_SHA/SM3，密钥协商算法ECDH，密钥派生算法PBKDF2，没有使用任何私有算法。
-   对称算法使用建议：
    -   AES/SM4算法ECB模式为非安全算法，不建议使用。
    -   对称算法的密钥的长度越长，安全等级越高，建议用户使用AES 128bit及以上的密钥。

-   非对称算法使用建议：
    -   RSA算法建议使用密钥长度3072bit及以上的密钥。
    -   RSA签名算法padding方式建议使用PSS padding方式。
    -   RSA加解密算法padding方式建议使用OAEP padding方式。
    -   ECDSA算法建议使用密钥长度256bit及以上的密钥。
    -   ECDSA算法曲线不建议使用NIST P256/384/521曲线。

-   摘要算法使用建议：
    -   SHA1/SHA224算法安全性低，不建议用户使用。
    -   SHA/HMAC\_SHA算法建议使用SHA256/HMAC\_SHA256及以上的算法。

-   密钥协商算法使用建议：
    -   ECDH算法建议使用密钥长度256bits及以上的密钥。
    -   DH算法建议使用密钥长度3072bits及以上的密钥。

-   密钥派生算法使用建议：
    -   迭代次数和安全性成正比例，也与计算时间成正比例，迭代次数越大，意味着计算密钥花费时间越长，同时抗暴力破解能力越强。对于性能不敏感或高安全性要求场景推荐迭代次数至少需要10000000次，其他场景迭代次数默认推荐至少10000次；对于性能有特殊要求的产品最低可以迭代1000次（NIST SP 800 132）。
    -   哈希函数推荐选择SHA256或更安全的哈希算法。
    -   盐值至少16Byte，应使用安全的随机数。
    -   用于口令单向哈希时，其输出长度应该不小于256bit。

## 其他使用安全注意事项<a name="ZH-CN_TOPIC_0000001880469009"></a>


### JTAG接口<a name="ZH-CN_TOPIC_0000001880628781"></a>

恶意者可通过JTAG接口，篡改系统和配置，恶意破坏系统。

建议用户采用以下措施：

-   产品出厂时，将JTAG接口从物理上删除。
-   芯片提供JTAG disable功能，软件通过写EFUSE，可从芯片层面直接永久关闭JTAG。

