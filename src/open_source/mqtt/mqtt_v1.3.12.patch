diff -Naru paho.mqtt.c/src/Clients.h paho.mqtt.c_new/src/Clients.h
--- paho.mqtt.c/src/Clients.h	2025-02-12 14:43:06.716221000 +0800
+++ paho.mqtt.c_new/src/Clients.h	2025-02-12 14:11:54.362411500 +0800
@@ -3,11 +3,11 @@
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
- * and Eclipse Distribution License v1.0 which accompany this distribution. 
+ * and Eclipse Distribution License v1.0 which accompany this distribution.
  *
- * The Eclipse Public License is available at 
+ * The Eclipse Public License is available at
  *    https://www.eclipse.org/legal/epl-2.0/
- * and the Eclipse Distribution License is available at 
+ * and the Eclipse Distribution License is available at
  *   http://www.eclipse.org/org/documents/edl-v10.php.
  *
  * Contributors:
@@ -30,6 +30,16 @@
 #if defined(OPENSSL)
 #include <openssl/ssl.h>
 #endif
+
+#if defined(MBEDTLS)
+#include <mbedtls/ctr_drbg.h>
+#include <mbedtls/entropy.h>
+#include <mbedtls/ssl.h>
+#if defined(MBEDTLS_USE_CRT)
+#include <mbedtls/x509_crt.h>
+#endif /* MBEDTLS_USE_CRT */
+#endif /* MBEDTLS */
+
 #include "MQTTClient.h"
 #include "LinkedList.h"
 #include "MQTTClientPersistence.h"
@@ -62,6 +72,9 @@
 	START_TIME_TYPE lastTouch;		    /**> used for retry and expiry */
 	char nextMessageType;	/**> PUBREC, PUBREL, PUBCOMP */
 	int len;				/**> length of the whole structure+data */
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	int retryTime;
+#endif
 } Messages;
 
 /**
@@ -76,13 +89,30 @@
 	int qos;
 } willMessages;
 
+#if defined(MBEDTLS)
+typedef struct
+{
+	mbedtls_ssl_config conf;
+	mbedtls_entropy_context entropy;
+	mbedtls_ctr_drbg_context ctr_drbg;
+#if defined(MBEDTLS_USE_CRT)
+	mbedtls_x509_crt cacert;
+	mbedtls_x509_crt clicert;
+	mbedtls_pk_context pkey;
+#endif /* MBEDTLS_USE_CRT */
+} SSL_CTX;
+
+typedef mbedtls_ssl_context SSL;
+typedef mbedtls_ssl_session SSL_SESSION;
+#endif /* MBEDTLS */
+
 typedef struct
 {
 	SOCKET socket;
 	START_TIME_TYPE lastSent;
 	START_TIME_TYPE lastReceived;
 	START_TIME_TYPE lastPing;
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	SSL* ssl;
 	SSL_CTX* ctx;
 	char *https_proxy;
@@ -141,6 +171,9 @@
 	int connect_sent;               /**< the current number of outbound messages on reconnect that we've sent */
 	List* messageQueue;             /**< inbound complete but undelivered messages */
 	List* outboundQueue;            /**< outbound queued messages */
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	int retryMsgs;              	/**< retry end but not waitForCompletion*/
+#endif
 	unsigned int qentry_seqno;
 	void* phandle;                  /**< the persistence handle */
 	MQTTClient_persistence* persistence; /**< a persistence implementation */
@@ -153,7 +186,7 @@
 	int sessionExpiry;              /**< MQTT 5 session expiry */
 	char* httpProxy;                /**< HTTP proxy */
 	char* httpsProxy;               /**< HTTPS proxy */
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	MQTTClient_SSLOptions *sslopts; /**< the SSL/TLS connect options */
 	SSL_SESSION* session;           /**< SSL session pointer for fast handhake */
 #endif
diff -Naru paho.mqtt.c/src/Heap.c paho.mqtt.c_new/src/Heap.c
--- paho.mqtt.c/src/Heap.c	2025-02-12 14:43:06.808972300 +0800
+++ paho.mqtt.c_new/src/Heap.c	2025-02-12 14:11:54.362411500 +0800
@@ -49,7 +49,7 @@
 #undef realloc
 #undef free
 
-#if defined(_WIN32) || defined(_WIN64)
+#if defined(_WIN32) || defined(_WIN64) || defined(COMPAT_CMSIS)
 mutex_type heap_mutex;
 #else
 static pthread_mutex_t heap_mutex_store = PTHREAD_MUTEX_INITIALIZER;
diff -Naru paho.mqtt.c/src/LinkedList.c paho.mqtt.c_new/src/LinkedList.c
--- paho.mqtt.c/src/LinkedList.c	2025-02-12 14:43:06.926524500 +0800
+++ paho.mqtt.c_new/src/LinkedList.c	2025-02-12 14:11:54.374411500 +0800
@@ -3,11 +3,11 @@
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
- * and Eclipse Distribution License v1.0 which accompany this distribution. 
+ * and Eclipse Distribution License v1.0 which accompany this distribution.
  *
- * The Eclipse Public License is available at 
+ * The Eclipse Public License is available at
  *    https://www.eclipse.org/legal/epl-2.0/
- * and the Eclipse Distribution License is available at 
+ * and the Eclipse Distribution License is available at
  *   http://www.eclipse.org/org/documents/edl-v10.php.
  *
  * Contributors:
@@ -137,7 +137,11 @@
  * @param content pointer to the list item content itself
  * @return the list item found, or NULL
  */
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+ListElement* _ListFind(List* aList, void* content) // conflict with libbt_host.a
+#else
 ListElement* ListFind(List* aList, void* content)
+#endif
 {
 	return ListFindItem(aList, content, NULL);
 }
@@ -291,7 +295,11 @@
  * @param aList the list from which the item is to be removed
  * @return 1=item removed, 0=item not removed
  */
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+int _ListRemoveHead(List* aList) // conflict with libbt_host.a
+#else
 int ListRemoveHead(List* aList)
+#endif
 {
 	free(ListDetachHead(aList));
 	return 0;
diff -Naru paho.mqtt.c/src/LinkedList.h paho.mqtt.c_new/src/LinkedList.h
--- paho.mqtt.c/src/LinkedList.h	2025-02-12 14:43:06.962732600 +0800
+++ paho.mqtt.c_new/src/LinkedList.h	2025-02-12 14:11:54.378411500 +0800
@@ -3,11 +3,11 @@
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
- * and Eclipse Distribution License v1.0 which accompany this distribution. 
+ * and Eclipse Distribution License v1.0 which accompany this distribution.
  *
- * The Eclipse Public License is available at 
+ * The Eclipse Public License is available at
  *    https://www.eclipse.org/legal/epl-2.0/
- * and the Eclipse Distribution License is available at 
+ * and the Eclipse Distribution License is available at
  *   http://www.eclipse.org/org/documents/edl-v10.php.
  *
  * Contributors:
@@ -83,7 +83,11 @@
 int ListRemove(List* aList, void* content);
 int ListRemoveItem(List* aList, void* content, int(*callback)(void*, void*));
 void* ListDetachHead(List* aList);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+int _ListRemoveHead(List* aList); // conflict with libbt_host.a
+#else
 int ListRemoveHead(List* aList);
+#endif
 void* ListPopTail(List* aList);
 
 int ListDetach(List* aList, void* content);
@@ -96,7 +100,11 @@
 ListElement* ListNextElement(List* aList, ListElement** pos);
 ListElement* ListPrevElement(List* aList, ListElement** pos);
 
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+ListElement* _ListFind(List* aList, void* content); // conflict with libbt_host.a
+#else
 ListElement* ListFind(List* aList, void* content);
+#endif
 ListElement* ListFindItem(List* aList, void* content, int(*callback)(void*, void*));
 
 int intcompare(void* a, void* b);
diff -Naru paho.mqtt.c/src/Log.c paho.mqtt.c_new/src/Log.c
--- paho.mqtt.c/src/Log.c	2025-02-12 14:43:07.000926600 +0800
+++ paho.mqtt.c_new/src/Log.c	2025-02-12 14:11:54.378411500 +0800
@@ -39,8 +39,10 @@
 #include <string.h>
 
 #if !defined(_WIN32) && !defined(_WIN64)
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 #include <syslog.h>
 #include <sys/stat.h>
+#endif
 #define GETTIMEOFDAY 1
 #else
 #define snprintf _snprintf
@@ -52,7 +54,11 @@
 	#include <sys/timeb.h>
 #endif
 
-#if !defined(_WIN32) && !defined(_WIN64)
+#if defined(IOT_CONNECT)
+#include "atiny_mqtt_commu.h"
+#endif
+
+#if !defined(_WIN32) && !defined(_WIN64) && !defined(IOT_CONNECT)
 /**
  * _unlink mapping for linux
  */
@@ -63,7 +69,17 @@
 #if !defined(min)
 #define min(A,B) ( (A) < (B) ? (A):(B))
 #endif
-
+#if defined(IOT_LITEOS_ADAPT)
+#include "osal_debug.h"
+#endif
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+trace_settings_type trace_settings =
+{
+	TRACE_MINIMUM,
+	5,
+	INVALID_LEVEL
+};
+#else
 trace_settings_type trace_settings =
 {
 #if defined(HIGH_PERFORMANCE)
@@ -74,6 +90,7 @@
 	400,
 	INVALID_LEVEL
 };
+#endif
 
 #define MAX_FUNCTION_NAME_LENGTH 256
 
@@ -100,17 +117,21 @@
 static traceEntry* trace_queue = NULL;
 static int trace_queue_size = 0;
 
+#if !defined (IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 static FILE* trace_destination = NULL;	/**< flag to indicate if trace is to be sent to a stream */
 static char* trace_destination_name = NULL; /**< the name of the trace file */
 static char* trace_destination_backup_name = NULL; /**< the name of the backup trace file */
 static int lines_written = 0; /**< number of lines written to the current output file */
 static int max_lines_per_file = 1000; /**< maximum number of lines to write to one trace file */
+#endif
 static enum LOG_LEVELS trace_output_level = INVALID_LEVEL;
 static Log_traceCallback* trace_callback = NULL;
 static traceEntry* Log_pretrace(void);
+#if !defined (IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 static char* Log_formatTraceEntry(traceEntry* cur_entry);
 static void Log_output(enum LOG_LEVELS log_level, const char *msg);
 static void Log_posttrace(enum LOG_LEVELS log_level, traceEntry* cur_entry);
+#endif
 static void Log_trace(enum LOG_LEVELS log_level, const char *buf);
 #if 0
 static FILE* Log_destToFile(const char *dest);
@@ -123,9 +144,13 @@
 #else
 struct timeb now_ts, last_ts;
 #endif
+#if defined (IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+static char msg_buf[100];
+#else
 static char msg_buf[512];
+#endif
 
-#if defined(_WIN32) || defined(_WIN64)
+#if defined(_WIN32) || defined(_WIN64) || defined(COMPAT_CMSIS)
 mutex_type log_mutex;
 #else
 static pthread_mutex_t log_mutex_store = PTHREAD_MUTEX_INITIALIZER;
@@ -135,6 +160,10 @@
 
 int Log_initialize(Log_nameValue* info)
 {
+#if defined (IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	(void)info;
+	return -1;
+#else
 	int rc = SOCKET_ERROR;
 	char* envval = NULL;
 #if !defined(_WIN32) && !defined(_WIN64)
@@ -220,6 +249,7 @@
 	Log_output(TRACE_MINIMUM, "=========================================================");
 exit:
 	return rc;
+#endif
 }
 
 
@@ -239,6 +269,9 @@
 
 void Log_terminate(void)
 {
+#if defined (IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	return;
+#else
 	free(trace_queue);
 	trace_queue = NULL;
 	trace_queue_size = 0;
@@ -260,6 +293,7 @@
 	next_index = 0;
 	trace_output_level = INVALID_LEVEL;
 	sametime_count = 0;
+#endif
 }
 
 
@@ -316,6 +350,7 @@
 	return cur_entry;
 }
 
+#if !defined (IOT_CONNECT) && !defined (IOT_LITEOS_ADAPT)
 static char* Log_formatTraceEntry(traceEntry* cur_entry)
 {
 	struct tm *timeinfo;
@@ -377,10 +412,15 @@
 	if (trace_callback)
 		(*trace_callback)(log_level, msg);
 }
+#endif
 
 
 static void Log_posttrace(enum LOG_LEVELS log_level, traceEntry* cur_entry)
 {
+#if defined (IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	(void)log_level;
+	(void)cur_entry;
+#else
 	if (((trace_output_level == -1) ? log_level >= trace_settings.trace_level : log_level >= trace_output_level))
 	{
 		char* msg = NULL;
@@ -390,6 +430,7 @@
 
 		Log_output(log_level, msg);
 	}
+#endif
 }
 
 
@@ -437,7 +478,13 @@
 		va_start(args, format);
 		vsnprintf(msg_buf, sizeof(msg_buf), format, args);
 
+#if defined(IOT_CONNECT)
+		atiny_printf("%s\n", msg_buf);
+#elif defined(IOT_LITEOS_ADAPT)
+        osal_printk("%s\n", msg_buf);
+#else
 		Log_trace(log_level, msg_buf);
+#endif
 		va_end(args);
 		Thread_unlock_mutex(log_mutex);
 	}
diff -Naru paho.mqtt.c/src/Log.h paho.mqtt.c_new/src/Log.h
--- paho.mqtt.c/src/Log.h	2025-02-12 14:43:07.036637700 +0800
+++ paho.mqtt.c_new/src/Log.h	2025-02-12 14:11:54.382411500 +0800
@@ -21,6 +21,9 @@
 #if defined(_WIN32) || defined(_WIN64)
 	#include <windows.h>
 	#define thread_id_type DWORD
+#elif defined(COMPAT_CMSIS)
+	#include <cmsis_os2.h>
+	typedef osThreadId_t thread_id_type;
 #else
 	#include <pthread.h>
 	#define thread_id_type pthread_t
diff -Naru paho.mqtt.c/src/Messages.c paho.mqtt.c_new/src/Messages.c
--- paho.mqtt.c/src/Messages.c	2025-02-12 14:43:07.067388100 +0800
+++ paho.mqtt.c_new/src/Messages.c	2025-02-12 14:11:54.446411500 +0800
@@ -46,8 +46,13 @@
 	"%d %s -> SUBACK msgid: %d (%d)", /* 7, was 40 */
 	"%d %s <- UNSUBSCRIBE msgid: %d", /* 8, was 41 */
 	"%d %s -> UNSUBACK msgid: %d (%d)", /* 9 */
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	"%d %s -> PUBLISH msgid: %d rc %d", /* 10 */
+	"%d %s <- PUBLISH msgid: %d", /* 11 */
+#else
 	"%d %s -> PUBLISH msgid: %d qos: %d retained: %d rc %d payload len(%d): %.*s", /* 10, was 42 */
 	"%d %s <- PUBLISH msgid: %d qos: %d retained: %d payload len(%d): %.*s", /* 11, was 46 */
+#endif
 	"%d %s -> PUBACK msgid: %d (%d)", /* 12, was 47 */
 	"%d %s -> PUBREC msgid: %d (%d)", /* 13, was 48 */
 	"%d %s <- PUBACK msgid: %d", /* 14, was 49 */
@@ -63,7 +68,11 @@
 	"%d %s <- UNSUBACK msgid: %d", /* 24, was 74 */
 	"%d %s -> UNSUBSCRIBE msgid: %d (%d)", /* 25, was 106 */
 	"%d %s <- CONNECT", /* 26 */
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	"%d %s -> PUBLISH rc: %d", /* 27 */
+#else
 	"%d %s -> PUBLISH qos: 0 retained: %d rc: %d payload len(%d): %.*s", /* 27 */
+#endif
 	"%d %s -> DISCONNECT (%d)", /* 28 */
 	"Socket error for client identifier %s, socket %d, peer address %s; ending connection", /* 29 */
 	"%d %s <- DISCONNECT (%d)", /* 30 */
diff -Naru paho.mqtt.c/src/MQTTClient.c paho.mqtt.c_new/src/MQTTClient.c
--- paho.mqtt.c/src/MQTTClient.c	2025-02-12 14:43:07.448813800 +0800
+++ paho.mqtt.c_new/src/MQTTClient.c	2025-02-12 14:11:54.386411500 +0800
@@ -67,8 +67,17 @@
 #include "StackTrace.h"
 #include "Heap.h"
 
+#if defined(IOT_CONNECT)
+#include "securec.h"
+#include "soc_socket_types.h"
+#include "atiny_mqtt_commu.h"
+#endif
+
 #if defined(OPENSSL)
 #include <openssl/ssl.h>
+#elif defined(MBEDTLS)
+#include <mbedtls/version.h>
+#include "Clients.h"
 #else
 #define URI_SSL   "ssl://"
 #define URI_MQTTS "mqtts://"
@@ -98,7 +107,7 @@
 void MQTTClient_global_init(MQTTClient_init_options* inits)
 {
 	MQTTClient_init();
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	SSLSocket_handleOpensslInit(inits->do_openssl_init);
 #endif
 }
@@ -244,7 +253,90 @@
 	return TRUE;
 }
 #endif
+#elif defined (COMPAT_CMSIS)
+
+static mutex_type mqttclient_mutex = NULL;
+mutex_type socket_mutex = NULL;
+static mutex_type subscribe_mutex = NULL;
+static mutex_type unsubscribe_mutex = NULL;
+static mutex_type connect_mutex = NULL;
+#if !defined(NO_HEAP_TRACKING)
+extern mutex_type stack_mutex;
+extern mutex_type heap_mutex;
+#endif
+extern mutex_type log_mutex;
+
+int MQTTClient_init(void)
+{
+	int rc = MQTTCLIENT_SUCCESS;
+	if ((mqttclient_mutex = Thread_create_mutex(&rc)) == NULL)
+	{
+		Log(TRACE_MIN, -1,"MQTTClient: error initializing client_mutex\n");
+		return rc;
+	}
+	if ((subscribe_mutex = Thread_create_mutex(&rc)) == NULL)
+	{
+		Log(TRACE_MIN, -1,"MQTTClient: error initializing subscribe_mutex\n");
+		return rc;
+	}
+	if ((unsubscribe_mutex = Thread_create_mutex(&rc)) == NULL)
+	{
+		Log(TRACE_MIN, -1,"MQTTClient: error initializing unsubscribe_mutex\n");
+		return rc;
+	}
+	if ((connect_mutex = Thread_create_mutex(&rc)) == NULL)
+	{
+		Log(TRACE_MIN, -1,"MQTTClient: error initializing connect_mutex\n");
+		return rc;
+	}
+#if !defined(NO_HEAP_TRACKING)
+	if ((stack_mutex = Thread_create_mutex(&rc)) == NULL)
+	{
+		Log(TRACE_MIN, -1,"MQTTClient: error initializing stack_mutex\n");
+		return rc;
+	}
+	if ((heap_mutex = Thread_create_mutex(&rc)) == NULL)
+	{
+		Log(TRACE_MIN, -1,"MQTTClient: error initializing heap_mutex\n");
+		return rc;
+	}
+#endif
+	if ((log_mutex = Thread_create_mutex(&rc)) == NULL)
+	{
+		Log(TRACE_MIN, -1,"MQTTClient: error initializing log_mutex\n");
+		return rc;
+	}
+	if ((socket_mutex = Thread_create_mutex(&rc)) == NULL)
+	{
+		Log(TRACE_MIN, -1,"MQTTClient: error initializing socket_mutex\n");
+		return rc;
+	}
+	return rc;
+}
 
+void MQTTClient_cleanup(void)
+{
+	Thread_destroy_mutex(connect_mutex);
+	connect_mutex = NULL;
+	Thread_destroy_mutex(subscribe_mutex);
+	subscribe_mutex = NULL;
+	Thread_destroy_mutex(unsubscribe_mutex);
+	unsubscribe_mutex = NULL;
+#if !defined(NO_HEAP_TRACKING)
+	Thread_destroy_mutex(stack_mutex);
+	stack_mutex = NULL;
+	Thread_destroy_mutex(heap_mutex);
+	heap_mutex = NULL;
+#endif
+	Thread_destroy_mutex(log_mutex);
+	log_mutex = NULL;
+	Thread_destroy_mutex(socket_mutex);
+	socket_mutex = NULL;
+	Thread_destroy_mutex(mqttclient_mutex);
+	mqttclient_mutex = NULL;
+}
+
+#define WINAPI
 #else
 static pthread_mutex_t mqttclient_mutex_store = PTHREAD_MUTEX_INITIALIZER;
 static mutex_type mqttclient_mutex = &mqttclient_mutex_store;
@@ -308,7 +400,7 @@
 {
 	char* serverURI;
 	const char* currentServerURI; /* when using HA options, set the currently used serverURI */
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	int ssl;
 #endif
 	int websocket;
@@ -380,6 +472,9 @@
 		int persistence_type, void* persistence_context, MQTTClient_createOptions* options)
 {
 	int rc = 0;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	int mem_ret = -1;
+#endif
 	MQTTClients *m = NULL;
 
 #if (defined(_WIN32) || defined(_WIN64)) && defined(PAHO_MQTT_STATIC)
@@ -389,8 +484,11 @@
 	FUNC_ENTRY;
 	if ((rc = Thread_lock_mutex(mqttclient_mutex)) != 0)
 		goto nounlock_exit;
-
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (handle == NULL || serverURI == NULL || clientId == NULL)
+#else
 	if (serverURI == NULL || clientId == NULL)
+#endif
 	{
 		rc = MQTTCLIENT_NULL_PARAMETER;
 		goto exit;
@@ -413,7 +511,7 @@
 		if (strncmp(URI_TCP, serverURI, strlen(URI_TCP)) != 0
 		 && strncmp(URI_MQTT, serverURI, strlen(URI_MQTT)) != 0
 		 && strncmp(URI_WS, serverURI, strlen(URI_WS)) != 0
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
          && strncmp(URI_SSL, serverURI, strlen(URI_SSL)) != 0
          && strncmp(URI_MQTTS, serverURI, strlen(URI_MQTTS)) != 0
 		 && strncmp(URI_WSS, serverURI, strlen(URI_WSS)) != 0
@@ -436,26 +534,89 @@
 		#if !defined(NO_HEAP_TRACKING)
 			Heap_initialize();
 		#endif
-		Log_initialize((Log_nameValue*)MQTTClient_getVersionInfo());
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
+			Log_initialize((Log_nameValue*)MQTTClient_getVersionInfo());
+#endif
 		bstate->clients = ListInitialize();
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		rc = Socket_outInitialize();
+#else
 		Socket_outInitialize();
+#endif
 		Socket_setWriteCompleteCallback(MQTTClient_writeComplete);
 		Socket_setWriteContinueCallback(MQTTClient_writeContinue);
 		Socket_setWriteAvailableCallback(MQTTProtocol_writeAvailable);
 		handles = ListInitialize();
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (bstate->clients == NULL || rc != 0 || handles == NULL)
+		{
+			#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
+				Log_terminate();
+			#endif
+			if (bstate->clients != NULL)
+			{
+				ListFree(bstate->clients);
+				bstate->clients = NULL;
+			}
+			if (rc == 0)
+				Socket_outTerminate();
+			if (handles != NULL)
+			{
+				ListFree(handles);
+				handles = NULL;
+			}
+			#if !defined(NO_HEAP_TRACKING)
+				Heap_terminate();
+			#endif
+
+			rc = PAHO_MEMORY_ERROR;
+			goto exit;
+		}
+#else
 #if defined(OPENSSL)
 		SSLSocket_initialize();
 #endif
+#endif
 		library_initialized = 1;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+#if defined(OPENSSL)
+		if (SSLSocket_initialize() != 1)
+#elif defined(MBEDTLS)
+		if (SSLSocket_initialize() != 0)
+#endif
+#if defined(OPENSSL) || defined(MBEDTLS)
+		{
+			MQTTClient_terminate();
+			rc = PAHO_MEMORY_ERROR;
+			goto exit;
+		}
+#endif
+#endif
 	}
 
 	if ((m = malloc(sizeof(MQTTClients))) == NULL)
 	{
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (bstate->clients->count == 0)
+			MQTTClient_terminate();
+#endif
 		rc = PAHO_MEMORY_ERROR;
 		goto exit;
 	}
 	*handle = m;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	mem_ret = memset_s(m, sizeof(MQTTClients), '\0', sizeof(MQTTClients));
+	if (mem_ret != 0)
+	{
+		free(m);
+		if (bstate->clients->count == 0)
+			MQTTClient_terminate();
+		rc = PAHO_MEMORY_ERROR;
+		goto exit;
+	}
+#else
 	memset(m, '\0', sizeof(MQTTClients));
+#endif
 	m->commandTimeout = 10000L;
 	if (strncmp(URI_TCP, serverURI, strlen(URI_TCP)) == 0)
 		serverURI += strlen(URI_TCP);
@@ -468,10 +629,15 @@
 	}
 	else if (strncmp(URI_SSL, serverURI, strlen(URI_SSL)) == 0)
 	{
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 		serverURI += strlen(URI_SSL);
 		m->ssl = 1;
 #else
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		free(m);
+		if (bstate->clients->count == 0)
+			MQTTClient_terminate();
+#endif
 		rc = MQTTCLIENT_SSL_NOT_SUPPORTED;
 		goto exit;
 #endif
@@ -488,32 +654,86 @@
 	}
 	else if (strncmp(URI_WSS, serverURI, strlen(URI_WSS)) == 0)
 	{
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 		serverURI += strlen(URI_WSS);
 		m->ssl = 1;
 		m->websocket = 1;
 #else
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		free(m);
+		if (bstate->clients->count == 0)
+			MQTTClient_terminate();
+#endif
 		rc = MQTTCLIENT_SSL_NOT_SUPPORTED;
 		goto exit;
 #endif
 	}
 	m->serverURI = MQTTStrdup(serverURI);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (m->serverURI == NULL)
+	{
+		free(m);
+		if (bstate->clients->count == 0)
+			MQTTClient_terminate();
+		rc = PAHO_MEMORY_ERROR;
+		goto exit;
+	}
+	if (ListAppend(handles, m, sizeof(MQTTClients)) == NULL)
+	{
+		free(m->serverURI);
+		free(m);
+		if (bstate->clients->count == 0)
+			MQTTClient_terminate();
+		rc = PAHO_MEMORY_ERROR;
+		goto exit;
+	}
+#else
 	ListAppend(handles, m, sizeof(MQTTClients));
+#endif
 
 	if ((m->c = malloc(sizeof(Clients))) == NULL)
 	{
-		ListRemove(handles, m);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		free(m->serverURI);
+#endif
+		ListRemove(handles, m); //m has been free in ListRemove.
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (bstate->clients->count == 0)
+			MQTTClient_terminate();
+#endif
+		rc = PAHO_MEMORY_ERROR;
+		goto exit;
+	}
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	mem_ret = memset_s(m->c, sizeof(Clients), '\0', sizeof(Clients));
+	if (mem_ret != 0)
+	{
+		free(m->c);
+		free(m->serverURI);
+		ListRemove(handles, m); //m has been free in ListRemove.
+		if (bstate->clients->count == 0)
+			MQTTClient_terminate();
 		rc = PAHO_MEMORY_ERROR;
 		goto exit;
 	}
+#else
 	memset(m->c, '\0', sizeof(Clients));
+#endif
 	m->c->context = m;
 	m->c->MQTTVersion = (options) ? options->MQTTVersion : MQTTVERSION_DEFAULT;
 	m->c->outboundMsgs = ListInitialize();
 	m->c->inboundMsgs = ListInitialize();
 	m->c->messageQueue = ListInitialize();
 	m->c->outboundQueue = ListInitialize();
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	m->c->retryMsgs = -1;
+#endif
 	m->c->clientID = MQTTStrdup(clientId);
+#if defined(ZERO_SOCK_FD_IS_INVALID)
+	m->c->net.socket = 0;
+#else
+	m->c->net.socket = -1;
+#endif
 	m->connect_sem = Thread_create_sem(&rc);
 	m->connack_sem = Thread_create_sem(&rc);
 	m->suback_sem = Thread_create_sem(&rc);
@@ -528,9 +748,94 @@
 			MQTTPersistence_restoreMessageQueue(m->c);
 	}
 #endif
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (m->c->outboundMsgs == NULL ||
+		m->c->inboundMsgs == NULL  ||
+		m->c->messageQueue == NULL ||
+		m->c->clientID == NULL ||
+		m->connect_sem == NULL ||
+		m->connack_sem == NULL ||
+		m->suback_sem  == NULL ||
+		m->unsuback_sem == NULL
+#if !defined(NO_PERSISTENCE)
+		|| rc != 0
+#endif
+		)
+	{
+#if !defined(NO_PERSISTENCE)
+		if (rc != 0)
+			MQTTPersistence_close(m->c);
+#endif
+		if (m->c->outboundMsgs != NULL)
+			ListFree(m->c->outboundMsgs);
+		if (m->c->inboundMsgs != NULL)
+			ListFree(m->c->inboundMsgs);
+		if (m->c->messageQueue != NULL)
+			ListFree(m->c->messageQueue);
+		if (m->c->clientID != NULL)
+			free(m->c->clientID);
+		if (m->connect_sem != NULL)
+			Thread_destroy_sem(m->connect_sem);
+		if (m->connack_sem != NULL)
+			Thread_destroy_sem(m->connack_sem);
+		if (m->suback_sem != NULL)
+			Thread_destroy_sem(m->suback_sem);
+		if (m->unsuback_sem != NULL)
+			Thread_destroy_sem(m->unsuback_sem);
+
+		free(m->c);
+		free(m->serverURI);
+		ListRemove(handles, m);
+		if (bstate->clients->count == 0)
+			MQTTClient_terminate();
+
+		rc = PAHO_MEMORY_ERROR;
+		goto exit;
+	}
+#endif
+
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (!ListAppend(bstate->clients, m->c, sizeof(Clients) + 3*sizeof(List)))
+	{
+#if !defined(NO_PERSISTENCE)
+		if (rc != 0)
+			MQTTPersistence_close(m->c);
+#endif
+		if (m->c->outboundMsgs != NULL)
+			ListFree(m->c->outboundMsgs);
+		if (m->c->inboundMsgs != NULL)
+			ListFree(m->c->inboundMsgs);
+		if (m->c->messageQueue != NULL)
+			ListFree(m->c->messageQueue);
+		if (m->c->clientID != NULL)
+			free(m->c->clientID);
+		if (m->connect_sem != NULL)
+			Thread_destroy_sem(m->connect_sem);
+		if (m->connack_sem != NULL)
+			Thread_destroy_sem(m->connack_sem);
+		if (m->suback_sem != NULL)
+			Thread_destroy_sem(m->suback_sem);
+		if (m->unsuback_sem != NULL)
+			Thread_destroy_sem(m->unsuback_sem);
+
+		free(m->c);
+		free(m->serverURI);
+		ListRemove(handles, m);
+		if (bstate->clients->count == 0)
+			MQTTClient_terminate();
+
+		rc = PAHO_MEMORY_ERROR;
+		goto exit;
+	}
+#else
 	ListAppend(bstate->clients, m->c, sizeof(Clients) + 3*sizeof(List));
+#endif
 
 exit:
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (handle != NULL && rc != 0)
+		*handle = NULL;
+#endif
 	Thread_unlock_mutex(mqttclient_mutex);
 nounlock_exit:
 	FUNC_EXIT_RC(rc);
@@ -559,7 +864,9 @@
 		#if !defined(NO_HEAP_TRACKING)
 			Heap_terminate();
 		#endif
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 		Log_terminate();
+#endif
 		library_initialized = 0;
 	}
 	FUNC_EXIT;
@@ -601,17 +908,36 @@
 	if (m->c)
 	{
 		SOCKET saved_socket = m->c->net.socket;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		char* saved_clientid = NULL;
+		if (m->c->clientID != NULL)
+			saved_clientid = MQTTStrdup(m->c->clientID);
+#else
 		char* saved_clientid = MQTTStrdup(m->c->clientID);
+#endif
 #if !defined(NO_PERSISTENCE)
 		MQTTPersistence_close(m->c);
 #endif
 		MQTTClient_emptyMessageQueue(m->c);
 		MQTTProtocol_freeClient(m->c);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (bstate != NULL && bstate->clients != NULL)
+		{
+			if (!ListRemove(bstate->clients, m->c))
+				Log(LOG_ERROR, 0, NULL);
+			else
+				Log(TRACE_MIN, 1, NULL, saved_clientid, saved_socket);
+		}
+
+		if (saved_clientid != NULL)
+			free(saved_clientid);
+#else
 		if (!ListRemove(bstate->clients, m->c))
 			Log(LOG_ERROR, 0, NULL);
 		else
 			Log(TRACE_MIN, 1, NULL, saved_clientid, saved_socket);
 		free(saved_clientid);
+#endif
 	}
 	if (m->serverURI)
 		free(m->serverURI);
@@ -619,10 +945,18 @@
 	Thread_destroy_sem(m->connack_sem);
 	Thread_destroy_sem(m->suback_sem);
 	Thread_destroy_sem(m->unsuback_sem);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (handles != NULL && ListRemove(handles, m) == 0)
+#else
 	if (!ListRemove(handles, m))
+#endif
 		Log(LOG_ERROR, -1, "free error");
 	*handle = NULL;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (bstate != NULL && bstate->clients != NULL && bstate->clients->count == 0)
+#else
 	if (bstate->clients->count == 0)
+#endif
 		MQTTClient_terminate();
 
 exit:
@@ -825,7 +1159,9 @@
 static thread_return_type WINAPI MQTTClient_run(void* n)
 {
 	long timeout = 10L; /* first time in we have a small timeout.  Gets things started more quickly */
-
+#if defined(IOT_LITEOS_ADAPT)
+    int err_connack_sem_send = 0;
+#endif
 	FUNC_ENTRY;
 	Thread_set_name("MQTTClient_run");
 	Thread_lock_mutex(mqttclient_mutex);
@@ -834,6 +1170,11 @@
 	running = 1;
 	while (!tostop)
 	{
+#if defined(IOT_LITEOS_ADAPT)
+        if (err_connack_sem_send == 1) {
+            osal_msleep(20); /* 20:睡眠20毫秒. tcp连接已建立，超时未收到connack时,让出cpu 20ms,防止此场景下看门狗挂死 */
+        }
+#endif
 		int rc = SOCKET_ERROR;
 		SOCKET sock = -1;
 		MQTTClients* m = NULL;
@@ -842,7 +1183,11 @@
 		Thread_unlock_mutex(mqttclient_mutex);
 		pack = MQTTClient_cycle(&sock, timeout, &rc);
 		Thread_lock_mutex(mqttclient_mutex);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (tostop != 0 || handles == NULL)
+#else
 		if (tostop)
+#endif
 			break;
 		timeout = 100L;
 
@@ -858,6 +1203,10 @@
 			/* assert: should not happen */
 			continue;
 		}
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (m->c != NULL && m->c->messageQueue != NULL && m->c->messageQueue->count > 0)
+			timeout = 0L;
+#endif
 		if (rc == SOCKET_ERROR)
 		{
 			if (m->c->connected)
@@ -874,6 +1223,9 @@
 				{
 					Log(TRACE_MIN, -1, "Posting connack semaphore for client %s", m->c->clientID);
 					m->c->connect_state = NOT_IN_PROGRESS;
+#if defined(IOT_LITEOS_ADAPT)
+                    err_connack_sem_send = 1;
+#endif
 					Thread_post_sem(m->connack_sem);
 				}
 			}
@@ -890,6 +1242,9 @@
 
 				Log(TRACE_MIN, -1, "Calling messageArrived for client %s, queue depth %d",
 					m->c->clientID, m->c->messageQueue->count);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+				uapi_watchdog_kick();
+#endif
 				Thread_unlock_mutex(mqttclient_mutex);
 				rc = (*(m->ma))(m->context, qe->topicName, topicLen, qe->msg);
 				Thread_lock_mutex(mqttclient_mutex);
@@ -972,7 +1327,7 @@
 			}
 			else if (m->c->connect_state == TCP_IN_PROGRESS)
 			{
-				int error;
+				int error = 0;
 				socklen_t len = sizeof(error);
 
 				if ((m->rc = getsockopt(m->c->net.socket, SOL_SOCKET, SO_ERROR, (char*)&error, &len)) == 0)
@@ -981,7 +1336,7 @@
 				m->c->connect_state = NOT_IN_PROGRESS;
 				Thread_post_sem(m->connect_sem);
 			}
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 			else if (m->c->connect_state == SSL_IN_PROGRESS)
 			{
 				rc = m->c->sslopts->struct_version >= 3 ?
@@ -992,7 +1347,11 @@
 				if (rc == 1 || rc == SSL_FATAL)
 				{
 					if (rc == 1 && (m->c->cleansession == 0 && m->c->cleanstart == 0) && m->c->session == NULL)
+#if defined(OPENSSL)
 						m->c->session = SSL_get1_session(m->c->net.ssl);
+#elif defined(MBEDTLS)
+						mbedtls_ssl_get_session(m->c->net.ssl, m->c->session);
+#endif
 					m->rc = rc;
 					Log(TRACE_MIN, -1, "Posting connect semaphore for SSL client %s rc %d", m->c->clientID, m->rc);
 					m->c->connect_state = NOT_IN_PROGRESS;
@@ -1097,7 +1456,11 @@
 	client->good = 0;
 	client->ping_outstanding = 0;
 	client->ping_due = 0;
+#if defined(ZERO_SOCK_FD_IS_INVALID)
 	if (client->net.socket > 0)
+#else
+	if (client->net.socket >= 0)
+#endif
 	{
 		if (client->connected)
 			MQTTPacket_send_disconnect(client, reason, props);
@@ -1106,13 +1469,21 @@
 
 #if defined(OPENSSL)
 		SSL_SESSION_free(client->session); /* is a no-op if session is NULL */
+#elif defined(MBEDTLS)
+		mbedtls_ssl_session_free(client->session);
+#endif
+#if defined(OPENSSL) || defined(MBEDTLS)
 		client->session = NULL; /* show the session has been freed */
 		SSLSocket_close(&client->net);
 #endif
 		Socket_close(client->net.socket);
 		Thread_unlock_mutex(socket_mutex);
+#if defined(ZERO_SOCK_FD_IS_INVALID)
 		client->net.socket = 0;
-#if defined(OPENSSL)
+#else
+		client->net.socket = -1;
+#endif
+#if defined(OPENSSL) || defined(MBEDTLS)
 		client->net.ssl = NULL;
 #endif
 	}
@@ -1214,12 +1585,14 @@
 		int count = 0;
 
 		Thread_start(MQTTClient_run, handle);
+#if defined(IOT_CONNECT)
+		MQTTTime_sleep(100L);
+#endif
 		if (MQTTTime_elapsed(start) >= millisecsTimeout)
 		{
 			rc = SOCKET_ERROR;
 			goto exit;
 		}
-
 		while (!running && ++count < 5)
 		{
 			Thread_unlock_mutex(mqttclient_mutex);
@@ -1234,15 +1607,15 @@
 	}
 
 	Log(TRACE_MIN, -1, "Connecting to serverURI %s with MQTT version %d", serverURI, MQTTVersion);
-#if defined(OPENSSL)
-#if defined(__GNUC__) && defined(__linux__)
+#if defined(OPENSSL) || defined(MBEDTLS)
+#if defined(__GNUC__) && defined(__linux__) && !defined(__LITEOS__)
 	rc = MQTTProtocol_connect(serverURI, m->c, m->ssl, m->websocket, MQTTVersion, connectProperties, willProperties,
 			millisecsTimeout - MQTTTime_elapsed(start));
 #else
 	rc = MQTTProtocol_connect(serverURI, m->c, m->ssl, m->websocket, MQTTVersion, connectProperties, willProperties);
 #endif
 #else
-#if defined(__GNUC__) && defined(__linux__)
+#if defined(__GNUC__) && defined(__linux__) && !defined(__LITEOS__)
 	rc = MQTTProtocol_connect(serverURI, m->c, m->websocket, MQTTVersion, connectProperties, willProperties,
 			millisecsTimeout - MQTTTime_elapsed(start));
 #else
@@ -1268,7 +1641,7 @@
 			rc = SOCKET_ERROR;
 			goto exit;
 		}
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 		if (m->ssl)
 		{
 			int port1;
@@ -1289,7 +1662,11 @@
 			if (setSocketForSSLrc != MQTTCLIENT_SUCCESS)
 			{
 				if (m->c->session != NULL)
+#if defined(OPENSSL)
 					if ((rc = SSL_set_session(m->c->net.ssl, m->c->session)) != 1)
+#elif defined(MBEDTLS)
+					if ((rc = mbedtls_ssl_set_session(m->c->net.ssl, m->c->session)) != 0)
+#endif
 						Log(TRACE_MIN, -1, "Failed to set SSL session with stored data, non critical");
 				rc = m->c->sslopts->struct_version >= 3 ?
 					SSLSocket_connect(m->c->net.ssl, m->c->net.socket, serverURI,
@@ -1322,7 +1699,11 @@
 							goto exit;
 						}
 						if ((m->c->cleansession == 0 && m->c->cleanstart == 0) && m->c->session == NULL)
+#if defined(OPENSSL)
 							m->c->session = SSL_get1_session(m->c->net.ssl);
+#elif defined(MBEDTLS)
+							mbedtls_ssl_get_session(m->c->net.ssl, m->c->session);
+#endif
 					}
 				}
 			}
@@ -1362,7 +1743,7 @@
 		}
 	}
 
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	if (m->c->connect_state == SSL_IN_PROGRESS) /* SSL connect sent - wait for completion */
 	{
 		Thread_unlock_mutex(mqttclient_mutex);
@@ -1374,7 +1755,11 @@
 			goto exit;
 		}
 		if((m->c->cleansession == 0 && m->c->cleanstart == 0) && m->c->session == NULL)
+#if defined(OPENSSL)
 			m->c->session = SSL_get1_session(m->c->net.ssl);
+#elif defined(MBEDTLS)
+			mbedtls_ssl_get_session(m->c->net.ssl, m->c->session);
+#endif
 
 		if ( m->websocket )
 		{
@@ -1472,8 +1857,11 @@
 		}
 	}
 	else
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		MQTTClient_disconnect1(handle, 0, 0, MQTTVersion == 3, MQTTREASONCODE_SUCCESS, NULL); /* don't want to call connection lost */
+#else
 		MQTTClient_disconnect1(handle, 0, 0, (MQTTVersion == 3), MQTTREASONCODE_SUCCESS, NULL); /* don't want to call connection lost */
-
+#endif
 	resp.reasonCode = rc;
 	FUNC_EXIT_RC(resp.reasonCode);
 	return resp;
@@ -1501,6 +1889,9 @@
 	ELAPSED_TIME_TYPE millisecsTimeout = 30000L;
 	MQTTResponse rc = MQTTResponse_initializer;
 	int MQTTVersion = 0;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	int mem_ret = -1;
+#endif
 
 	FUNC_ENTRY;
 	rc.reasonCode = SOCKET_ERROR;
@@ -1517,7 +1908,11 @@
 		m->c->cleanstart = options->cleanstart;
 	else
 		m->c->cleansession = options->cleansession;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	m->c->maxInflightMessages = (options->reliable) ? 1 : 2;
+#else
 	m->c->maxInflightMessages = (options->reliable) ? 1 : 10;
+#endif
 	if (options->struct_version >= 6)
 	{
 		if (options->maxInflightMessages > 0)
@@ -1568,6 +1963,9 @@
 			if ((m->c->will->payload = malloc(m->c->will->payloadlen)) == NULL)
 			{
 				free(m->c->will);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+				m->c->will = NULL;
+#endif
 				rc.reasonCode = PAHO_MEMORY_ERROR;
 				goto exit;
 			}
@@ -1583,7 +1981,7 @@
 		m->c->will->topic = MQTTStrdup(options->will->topicName);
 	}
 
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	if (m->c->sslopts)
 	{
 		if (m->c->sslopts->trustStore)
@@ -1612,7 +2010,18 @@
 			rc.reasonCode = PAHO_MEMORY_ERROR;
 			goto exit;
 		}
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		mem_ret = memset_s(m->c->sslopts, sizeof(MQTTClient_SSLOptions), '\0', sizeof(MQTTClient_SSLOptions));
+		if (mem_ret != 0)
+		{
+			free(m->c->sslopts);
+			m->c->sslopts = NULL;
+			rc.reasonCode = PAHO_MEMORY_ERROR;
+			goto exit;
+		}
+#else
 		memset(m->c->sslopts, '\0', sizeof(MQTTClient_SSLOptions));
+#endif
 		m->c->sslopts->struct_version = options->ssl->struct_version;
 		if (options->ssl->trustStore)
 			m->c->sslopts->trustStore = MQTTStrdup(options->ssl->trustStore);
@@ -1649,6 +2058,28 @@
 		    m->c->sslopts->protos = options->ssl->protos;
 		    m->c->sslopts->protos_len = options->ssl->protos_len;
 		}
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+#if defined(MBEDTLS_USE_CRT)
+		if (options->ssl->los_trustStore != NULL)
+			m->c->sslopts->los_trustStore = options->ssl->los_trustStore;
+		if (options->ssl->los_keyStore != NULL)
+			m->c->sslopts->los_keyStore = options->ssl->los_keyStore;
+		if (options->ssl->los_privateKey != NULL)
+			m->c->sslopts->los_privateKey = options->ssl->los_privateKey;
+#endif /* MBEDTLS_USE_CRT */
+#if defined(MBEDTLS_USE_PSK)
+		if (options->ssl->psk != NULL)
+		{
+			m->c->sslopts->psk = options->ssl->psk;
+			m->c->sslopts->psk_len = options->ssl->psk_len;
+		}
+		if (options->ssl->psk_id != NULL)
+		{
+			m->c->sslopts->psk_id = options->ssl->psk_id;
+			m->c->sslopts->psk_id_len = options->ssl->psk_id_len;
+		}
+#endif /* MBEDTLS_USE_PSK */
+#endif
 	}
 #endif
 
@@ -1684,7 +2115,22 @@
 		MQTTVersion = options->MQTTVersion;
 	else
 		MQTTVersion = MQTTVERSION_DEFAULT;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (MQTTVersion == MQTTVERSION_DEFAULT)
+		MQTTVersion = MQTTVERSION_3_1_1;
 
+	if (MQTTVersion != MQTTVERSION_3_1)
+	{
+		rc = MQTTClient_connectURIVersion(handle, options, serverURI, MQTTVersion, start, millisecsTimeout,
+				connectProperties, willProperties);
+		if (rc.reasonCode == MQTTCLIENT_SUCCESS)
+			goto exit;
+	}
+	MQTTTime_sleep(50L); // wait for the disconnect to complete.
+	start = MQTTTime_start_clock();
+	rc = MQTTClient_connectURIVersion(handle, options, serverURI, MQTTVERSION_3_1, start, millisecsTimeout,
+			connectProperties, willProperties);
+#else
 	if (MQTTVersion == MQTTVERSION_DEFAULT)
 	{
 		rc = MQTTClient_connectURIVersion(handle, options, serverURI, 4, start, millisecsTimeout,
@@ -1698,7 +2144,7 @@
 	else
 		rc = MQTTClient_connectURIVersion(handle, options, serverURI, MQTTVersion, start, millisecsTimeout,
 				connectProperties, willProperties);
-
+#endif
 exit:
 	FUNC_EXIT_RC(rc.reasonCode);
 	return rc;
@@ -1766,7 +2212,7 @@
 		goto exit;
 	}
 
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	if (m->ssl && options->ssl == NULL)
 	{
 		rc.reasonCode = MQTTCLIENT_NULL_PARAMETER;
@@ -1798,7 +2244,7 @@
 	}
 
 
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	if (options->struct_version != 0 && options->ssl) /* check validity of SSL options structure */
 	{
 		if (strncmp(options->ssl->struct_id, "MQTS", 4) != 0 || options->ssl->struct_version < 0 || options->ssl->struct_version > 5)
@@ -1863,7 +2309,7 @@
 				serverURI += strlen(URI_WS);
 				m->websocket = 1;
 			}
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 			else if (strncmp(URI_SSL, serverURI, strlen(URI_SSL)) == 0)
 			{
 				serverURI += strlen(URI_SSL);
@@ -1953,11 +2399,19 @@
 exit:
 	if (stop)
 		MQTTClient_stop();
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (call_connection_lost && was_connected && m->cl != NULL)
+#else
 	if (call_connection_lost && m->cl && was_connected)
+#endif
 	{
 		sync.sem = Thread_create_sem(&rc);
 		Log(TRACE_MIN, -1, "Calling connectionLost for client %s", m->c->clientID);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		connectionLost_call(&sync);
+#else
 		Thread_start(connectionLost_call, &sync);
+#endif
 		Thread_wait_sem(sync.sem, 5000);
 		Thread_destroy_sem(sync.sem);
 	}
@@ -2020,6 +2474,21 @@
 	return rc;
 }
 
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+int MQTTClient_getConnectState(MQTTClient handle)
+{
+	MQTTClients* m = handle;
+	int rc = 0;
+
+	FUNC_ENTRY;
+	Thread_lock_mutex(mqttclient_mutex);
+	if (m != NULL && m->c != NULL)
+		rc = m->c->connect_state;
+	Thread_unlock_mutex(mqttclient_mutex);
+	FUNC_EXIT_RC(rc);
+	return rc;
+}
+#endif
 
 MQTTResponse MQTTClient_subscribeMany5(MQTTClient handle, int count, char* const* topic,
 		int* qos, MQTTSubscribe_options* opts, MQTTProperties* props)
@@ -2068,7 +2537,23 @@
 	}
 
 	topics = ListInitialize();
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (topics == NULL)
+	{
+		rc = PAHO_MEMORY_ERROR;
+		goto exit;
+	}
+#endif
 	qoss = ListInitialize();
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (qoss == NULL)
+	{
+		ListFreeNoContent(topics);
+		rc = PAHO_MEMORY_ERROR;
+		goto exit;
+	}
+#endif
+
 	for (i = 0; i < count; i++)
 	{
 		ListAppend(topics, topic[i], strlen(topic[i]));
@@ -2167,7 +2652,10 @@
 		response.reasonCode = MQTTCLIENT_WRONG_MQTT_VERSION;
 	else
 		response = MQTTClient_subscribeMany5(handle, count, topic, qos, NULL, NULL);
-
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (*qos == MQTT_BAD_SUBSCRIBE) /* addition for MQTT 3.1.1 - error code from subscribe */
+		response.reasonCode = MQTT_BAD_SUBSCRIBE;
+#endif
 	return response.reasonCode;
 }
 
@@ -2240,6 +2728,13 @@
 	}
 
 	topics = ListInitialize();
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (topics == NULL)
+	{
+		rc = PAHO_MEMORY_ERROR;
+		goto exit;
+	}
+#endif
 	for (i = 0; i < count; i++)
 		ListAppend(topics, topic[i], strlen(topic[i]));
 	rc = MQTTProtocol_unsubscribe(m->c, topics, msgid, props);
@@ -2364,6 +2859,10 @@
 	while (m->c->outboundMsgs->count >= m->c->maxInflightMessages ||
          Socket_noPendingWrites(m->c->net.socket) == 0) /* wait until the socket is free of large packets being written */
 	{
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		rc = MQTTCLIENT_FAILURE;
+		goto exit;
+#else
 		if (blocked == 0)
 		{
 			blocked = 1;
@@ -2377,6 +2876,7 @@
 			rc = MQTTCLIENT_FAILURE;
 			goto exit;
 		}
+#endif
 	}
 	if (blocked == 1)
 		Log(TRACE_MIN, -1, "Resuming publish now queue not full for client %s", m->c->clientID);
@@ -2447,6 +2947,12 @@
 		}
 		rc = (qos > 0 || m->c->connected == 1) ? MQTTCLIENT_SUCCESS : MQTTCLIENT_FAILURE;
 	}
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	else if (rc == PAHO_MEMORY_ERROR)
+	{
+		goto exit_and_free;
+	}
+#endif
 
 	if (deliveryToken && qos > 0)
 		*deliveryToken = msg->msgid;
@@ -2552,7 +3058,11 @@
 		MQTTProtocol_retry(now, 1, 0);
 	}
 	else
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		MQTTProtocol_retry(now, 1, 0);
+#else
 		MQTTProtocol_retry(now, 0, 0);
+#endif
 	FUNC_EXIT;
 }
 
@@ -2565,7 +3075,7 @@
 	START_TIME_TYPE start;
 
 	FUNC_ENTRY;
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	if ((*sock = SSLSocket_getPendingRead()) == -1)
 	{
 		/* 0 from getReadySocket indicates no work to do, rc -1 == error */
@@ -2573,13 +3083,21 @@
 		start = MQTTTime_start_clock();
 		*sock = Socket_getReadySocket(0, (int)timeout, socket_mutex, rc);
 		*rc = rc1;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (*sock == SOCKET_ERROR && timeout >= 100L && MQTTTime_elapsed(start) < (int64_t)10)
+#else
 		if (*sock == 0 && timeout >= 100L && MQTTTime_elapsed(start) < (int64_t)10)
+#endif
 			MQTTTime_sleep(100L);
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	}
 #endif
 	Thread_lock_mutex(mqttclient_mutex);
+#if defined(ZERO_SOCK_FD_IS_INVALID)
 	if (*sock > 0 && rc1 == 0)
+#else
+	if (*sock >= 0 && rc1 == 0)
+#endif
 	{
 		MQTTClients* m = NULL;
 		if (ListFindItem(handles, sock, clientSockCompare) != NULL)
@@ -2595,6 +3113,12 @@
 				pack = MQTTPacket_Factory(m->c->MQTTVersion, &m->c->net, rc);
 				if (*rc == TCPSOCKET_INTERRUPTED)
 					*rc = 0;
+#if !defined(ZERO_SOCK_FD_IS_INVALID)
+#if !defined(IOT_LITEOS_ADAPT)
+				if (*rc == EXT_SOCKET_RET_INVALID_SOCKET)
+					*rc = SOCKET_ERROR;
+#endif
+#endif
 			}
 		}
 
@@ -2703,14 +3227,14 @@
 					break;
 				if (m->c->connect_state == TCP_IN_PROGRESS)
 				{
-					int error;
+					int error = 0;
 					socklen_t len = sizeof(error);
 
 					if ((*rc = getsockopt(m->c->net.socket, SOL_SOCKET, SO_ERROR, (char*)&error, &len)) == 0)
 						*rc = error;
 					break;
 				}
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 				else if (m->c->connect_state == SSL_IN_PROGRESS)
 				{
 
@@ -2724,7 +3248,11 @@
 					else if (*rc == 1) /* rc == 1 means SSL connect has finished and succeeded */
 					{
 						if ((m->c->cleansession == 0 && m->c->cleanstart == 0) && m->c->session == NULL)
+#if defined(OPENSSL)
 							m->c->session = SSL_get1_session(m->c->net.ssl);
+#elif defined(MBEDTLS)
+							mbedtls_ssl_get_session(m->c->net.ssl, m->c->session);
+#endif
 						break;
 					}
 				}
@@ -2741,7 +3269,7 @@
 				}
 				else if (m->c->connect_state == WAIT_FOR_CONNACK)
 				{
-					int error;
+					int error = 0;
 					socklen_t len = sizeof(error);
 					if (getsockopt(m->c->net.socket, SOL_SOCKET, SO_ERROR, (char*)&error, &len) == 0)
 					{
@@ -2891,6 +3419,14 @@
 		}
 		if (ListFindItem(m->c->outboundMsgs, &mdt, messageIDCompare) == NULL)
 		{
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			if (m->c->retryMsgs == mdt)
+			{
+				rc = MQTTCLIENT_FAILURE;
+				Log(TRACE_MIN, -1, "msgid = %d, retry end.\n", mdt);
+				goto exit;
+			}
+#endif
 			rc = MQTTCLIENT_SUCCESS; /* well we couldn't find it */
 			goto exit;
 		}
@@ -3004,6 +3540,9 @@
 
 	libinfo[i].name = "OpenSSL directory";
 	libinfo[i++].value = SSLeay_version(SSLEAY_DIR);
+#elif defined(MBEDTLS)
+	libinfo[i].name = "MbedTLS Version";
+	libinfo[i++].value = MBEDTLS_VERSION_STRING;
 #endif
 	libinfo[i].name = NULL;
 	libinfo[i].value = NULL;
diff -Naru paho.mqtt.c/src/MQTTClient.h paho.mqtt.c_new/src/MQTTClient.h
--- paho.mqtt.c/src/MQTTClient.h	2025-02-12 14:43:07.522718200 +0800
+++ paho.mqtt.c_new/src/MQTTClient.h	2025-02-12 14:11:54.394411500 +0800
@@ -656,6 +656,20 @@
 #define MQTT_SSL_VERSION_TLS_1_1 2
 #define MQTT_SSL_VERSION_TLS_1_2 3
 
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+typedef struct
+{
+	const unsigned char* body;            /**< string of cert in PEM format */
+	size_t size;  /**< binary payload data */
+} cert_string;
+
+typedef struct
+{
+	const unsigned char* body;            /**< string of key in KEY forma */
+	size_t size;  /**< binary payload data */
+} key_string;
+#endif
+
 /**
 * MQTTClient_sslProperties defines the settings to establish an SSL/TLS connection using the
 * OpenSSL library. It covers the following scenarios:
@@ -777,9 +791,27 @@
 	 * Exists only if struct_version >= 5
 	 */
 	unsigned int protos_len;
+
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	/** CA Certification */
+	const cert_string* los_trustStore;
+	/** client Certification */
+	const cert_string* los_keyStore;
+	/** client private key */
+	const key_string* los_privateKey;
+
+	const unsigned char* psk;
+	unsigned int psk_len;
+	const unsigned char* psk_id;
+	unsigned int psk_id_len;
+#endif
 } MQTTClient_SSLOptions;
 
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+#define MQTTClient_SSLOptions_initializer { {'M', 'Q', 'T', 'S'}, 5, NULL, NULL, NULL, NULL, NULL, 1, MQTT_SSL_VERSION_DEFAULT, 0, NULL, NULL, NULL, NULL, NULL, 0, NULL, 0, NULL, NULL, NULL, NULL, 0, NULL, 0 }
+#else
 #define MQTTClient_SSLOptions_initializer { {'M', 'Q', 'T', 'S'}, 5, NULL, NULL, NULL, NULL, NULL, 1, MQTT_SSL_VERSION_DEFAULT, 0, NULL, NULL, NULL, NULL, NULL, 0, NULL, 0 }
+#endif
 
 /**
   * MQTTClient_libraryInfo is used to store details relating to the currently used
@@ -978,10 +1010,14 @@
 	const char* httpsProxy;
 } MQTTClient_connectOptions;
 
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
 /** Initializer for connect options for MQTT 3.1.1 non-WebSocket connections */
+#define MQTTClient_connectOptions_initializer { {'M', 'Q', 'T', 'C'}, 8, 60, 1, 0, NULL, NULL, NULL, 30, 0, NULL,\
+0, NULL, MQTTVERSION_DEFAULT, {NULL, 0, 0}, {0, NULL}, -1, 0, NULL, NULL, NULL}
+#else
 #define MQTTClient_connectOptions_initializer { {'M', 'Q', 'T', 'C'}, 8, 60, 1, 1, NULL, NULL, NULL, 30, 0, NULL,\
 0, NULL, MQTTVERSION_DEFAULT, {NULL, 0, 0}, {0, NULL}, -1, 0, NULL, NULL, NULL}
-
+#endif
 /** Initializer for connect options for MQTT 5.0 non-WebSocket connections */
 #define MQTTClient_connectOptions_initializer5 { {'M', 'Q', 'T', 'C'}, 8, 60, 0, 1, NULL, NULL, NULL, 30, 0, NULL,\
 0, NULL, MQTTVERSION_5, {NULL, 0, 0}, {0, NULL}, -1, 1, NULL, NULL, NULL}
@@ -1085,7 +1121,9 @@
   */
 LIBMQTT_API int MQTTClient_isConnected(MQTTClient handle);
 
-
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+LIBMQTT_API int MQTTClient_getConnectState(MQTTClient handle);
+#endif
 /* Subscribe is synchronous.  QoS list parameter is changed on return to granted QoSs.
    Returns return code, MQTTCLIENT_SUCCESS == success, non-zero some sort of error (TBD) */
 
diff -Naru paho.mqtt.c/src/MQTTPacket.c paho.mqtt.c_new/src/MQTTPacket.c
--- paho.mqtt.c/src/MQTTPacket.c	2025-02-12 14:43:07.657630400 +0800
+++ paho.mqtt.c_new/src/MQTTPacket.c	2025-02-12 14:11:54.406411500 +0800
@@ -3,11 +3,11 @@
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
- * and Eclipse Distribution License v1.0 which accompany this distribution. 
+ * and Eclipse Distribution License v1.0 which accompany this distribution.
  *
- * The Eclipse Public License is available at 
+ * The Eclipse Public License is available at
  *    https://www.eclipse.org/legal/epl-2.0/
- * and the Eclipse Distribution License is available at 
+ * and the Eclipse Distribution License is available at
  *   http://www.eclipse.org/org/documents/edl-v10.php.
  *
  * Contributors:
@@ -228,7 +228,7 @@
 
 	if (rc == TCPSOCKET_COMPLETE)
 		net->lastSent = MQTTTime_now();
-	
+
 	if (rc != TCPSOCKET_INTERRUPTED)
 	  free(buf);
 
@@ -282,7 +282,7 @@
 
 	if (rc == TCPSOCKET_COMPLETE)
 		net->lastSent = MQTTTime_now();
-	
+
 	if (rc != TCPSOCKET_INTERRUPTED)
 	  free(buf);
 exit:
@@ -589,6 +589,10 @@
 		pack->properties = props;
 		if (MQTTProperties_read(&pack->properties, &curdata, enddata) != 1)
 		{
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			if (pack->topic != NULL)
+				free(pack->topic);
+#endif
 			if (pack->properties.array)
 				free(pack->properties.array);
 			if (pack)
@@ -903,12 +907,19 @@
 		rc = MQTTPacket_sends(net, header, &packetbufs, pack->MQTTVersion);
 		memcpy(pack->mask, packetbufs.mask, sizeof(pack->mask));
 	}
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (qos == 0)
+		Log(LOG_PROTOCOL, 27, NULL, net->socket, clientID, rc);
+	else
+		Log(LOG_PROTOCOL, 10, NULL, net->socket, clientID, pack->msgId, rc);
+#else
 	if (qos == 0)
 		Log(LOG_PROTOCOL, 27, NULL, net->socket, clientID, retained, rc, pack->payloadlen,
 				min(20, pack->payloadlen), pack->payload);
 	else
 		Log(LOG_PROTOCOL, 10, NULL, net->socket, clientID, pack->msgId, qos, retained, rc, pack->payloadlen,
 				min(20, pack->payloadlen), pack->payload);
+#endif
 exit_free:
 	if (rc != TCPSOCKET_INTERRUPTED)
 		free(topiclen);
diff -Naru paho.mqtt.c/src/MQTTPacket.h paho.mqtt.c_new/src/MQTTPacket.h
--- paho.mqtt.c/src/MQTTPacket.h	2025-02-12 14:43:07.697806500 +0800
+++ paho.mqtt.c_new/src/MQTTPacket.h	2025-02-12 14:11:54.406411500 +0800
@@ -3,11 +3,11 @@
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
- * and Eclipse Distribution License v1.0 which accompany this distribution. 
+ * and Eclipse Distribution License v1.0 which accompany this distribution.
  *
- * The Eclipse Public License is available at 
+ * The Eclipse Public License is available at
  *    https://www.eclipse.org/legal/epl-2.0/
- * and the Eclipse Distribution License is available at 
+ * and the Eclipse Distribution License is available at
  *   http://www.eclipse.org/org/documents/edl-v10.php.
  *
  * Contributors:
@@ -22,13 +22,15 @@
 #define MQTTPACKET_H
 
 #include "Socket.h"
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 #include "SSLSocket.h"
 #endif
 #include "LinkedList.h"
 #include "Clients.h"
 
+#if !defined(IOT_CONNECT) && !defined(__LITEOS__) && !defined(IOT_LITEOS_ADAPT)
 typedef unsigned int bool;
+#endif
 typedef void* (*pf)(int, unsigned char, char*, size_t);
 
 #include "MQTTProperties.h"
diff -Naru paho.mqtt.c/src/MQTTPacketOut.c paho.mqtt.c_new/src/MQTTPacketOut.c
--- paho.mqtt.c/src/MQTTPacketOut.c	2025-02-12 14:43:07.741454700 +0800
+++ paho.mqtt.c_new/src/MQTTPacketOut.c	2025-02-12 14:11:54.406411500 +0800
@@ -3,11 +3,11 @@
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
- * and Eclipse Distribution License v1.0 which accompany this distribution. 
+ * and Eclipse Distribution License v1.0 which accompany this distribution.
  *
- * The Eclipse Public License is available at 
+ * The Eclipse Public License is available at
  *    https://www.eclipse.org/legal/epl-2.0/
- * and the Eclipse Distribution License is available at 
+ * and the Eclipse Distribution License is available at
  *   http://www.eclipse.org/org/documents/edl-v10.php.
  *
  * Contributors:
@@ -292,10 +292,23 @@
 	Suback* pack = NULL;
 	char* curdata = data;
 	char* enddata = &data[datalen];
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	int ret = -1;
+#endif
 
 	FUNC_ENTRY;
 	if ((pack = malloc(sizeof(Suback))) == NULL)
 		goto exit;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	ret = memset_s(pack, sizeof(Suback), 0, sizeof(Suback));
+	if (ret != 0)
+	{
+		if (pack != NULL)
+			free(pack);
+		pack = NULL;
+		goto exit;
+	}
+#endif
 	pack->MQTTVersion = MQTTVersion;
 	pack->header.byte = aHeader;
 	if (enddata - curdata < 2)  /* Is there enough data to read the msgid? */
@@ -304,6 +317,7 @@
 		pack = NULL;
 		goto exit;
 	}
+
 	pack->msgId = readInt(&curdata);
 	if (MQTTVersion >= MQTTVERSION_5)
 	{
@@ -320,12 +334,28 @@
 		}
 	}
 	pack->qoss = ListInitialize();
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (pack->qoss == NULL)
+	{
+		if (pack->properties.array != NULL)
+			free(pack->properties.array);
+		if (pack != NULL)
+			free(pack);
+		pack = NULL; /* signal protocol error */
+		goto exit;
+
+	}
+#endif
 	while ((size_t)(curdata - data) < datalen)
 	{
 		unsigned int* newint;
 		newint = malloc(sizeof(unsigned int));
 		if (newint == NULL)
 		{
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			if (pack->qoss != NULL)
+				ListFree(pack->qoss);
+#endif
 			if (pack->properties.array)
 				free(pack->properties.array);
 			if (pack)
@@ -338,10 +368,18 @@
 	}
 	if (pack->qoss->count == 0)
 	{
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		ListFree(pack->qoss);
+		if (pack->properties.array)
+			free(pack->properties.array);
+		if (pack)
+			free(pack);
+#else
 		if (pack->properties.array)
 			free(pack->properties.array);
 		ListFree(pack->qoss);
 		free(pack);
+#endif
 		pack = NULL;
 	}
 exit:
@@ -441,12 +479,27 @@
 			goto exit;
 		}
 		pack->reasonCodes = ListInitialize();
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (pack->reasonCodes == NULL)
+		{
+			if (pack->properties.array != NULL)
+				free(pack->properties.array);
+			if (pack != NULL)
+				free(pack);
+			pack = NULL; /* signal protocol error */
+			goto exit;
+		}
+#endif
 		while ((size_t)(curdata - data) < datalen)
 		{
 			enum MQTTReasonCodes* newrc;
 			newrc = malloc(sizeof(enum MQTTReasonCodes));
 			if (newrc == NULL)
 			{
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+				if (pack->reasonCodes != NULL)
+					ListFree(pack->reasonCodes);
+#endif
 				if (pack->properties.array)
 					free(pack->properties.array);
 				if (pack)
diff -Naru paho.mqtt.c/src/MQTTPersistence.c paho.mqtt.c_new/src/MQTTPersistence.c
--- paho.mqtt.c/src/MQTTPersistence.c	2025-02-12 14:43:07.896703700 +0800
+++ paho.mqtt.c_new/src/MQTTPersistence.c	2025-02-12 14:11:54.406411500 +0800
@@ -3,11 +3,11 @@
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
- * and Eclipse Distribution License v1.0 which accompany this distribution. 
+ * and Eclipse Distribution License v1.0 which accompany this distribution.
  *
- * The Eclipse Public License is available at 
+ * The Eclipse Public License is available at
  *    https://www.eclipse.org/legal/epl-2.0/
- * and the Eclipse Distribution License is available at 
+ * and the Eclipse Distribution License is available at
  *   http://www.eclipse.org/org/documents/edl-v10.php.
  *
  * Contributors:
@@ -236,6 +236,15 @@
 				if (data_MQTTVersion == MQTTVERSION_5 && c->MQTTVersion < MQTTVERSION_5)
 				{
 					rc = MQTTCLIENT_PERSISTENCE_ERROR; /* can't restore version 5 data with a version 3 client */
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+					if (buffer != NULL)
+					{
+						free(buffer);
+						buffer = NULL;
+					}
+					if (msgkeys[i] != NULL)
+						free(msgkeys[i]);
+#endif
 					goto exit;
 				}
 
@@ -274,6 +283,17 @@
 						if (!key)
 						{
 							rc = PAHO_MEMORY_ERROR;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+							publish->topic = NULL;
+							MQTTPacket_freePublish(publish);
+							if (buffer != NULL)
+							{
+								free(buffer);
+								buffer = NULL;
+							}
+							if (msgkeys[i] != NULL)
+								free(msgkeys[i]);
+#endif
 							goto exit;
 						}
 						publish->MQTTVersion = c->MQTTVersion;
@@ -313,6 +333,16 @@
 						if (!key)
 						{
 							rc = PAHO_MEMORY_ERROR;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+							free(pubrel);
+							if (buffer != NULL)
+							{
+								free(buffer);
+								buffer = NULL;
+							}
+							if (msgkeys[i] != NULL)
+								free(msgkeys[i]);
+#endif
 							goto exit;
 						}
 						pubrel->MQTTVersion = c->MQTTVersion;
@@ -343,13 +373,19 @@
 				free(msgkeys[i]);
 			i++;
 		}
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 		if (msgkeys)
 			free(msgkeys);
+#endif
 	}
-	Log(TRACE_MINIMUM, -1, "%d sent messages and %d received messages restored for client %s\n", 
+	Log(TRACE_MINIMUM, -1, "%d sent messages and %d received messages restored for client %s\n",
 		msgs_sent, msgs_rcvd, c->clientID);
 	MQTTPersistence_wrapMsgID(c);
 exit:
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (msgkeys != NULL)
+		free(msgkeys);
+#endif
 	FUNC_EXIT_RC(rc);
 	return rc;
 }
@@ -653,7 +689,7 @@
 #endif
 	char key[KEYSIZE];
 	int chars = 0;
-	
+
 	FUNC_ENTRY;
 	if (client->MQTTVersion >= MQTTVERSION_5)
 		chars = snprintf(key, KEYSIZE, "%s%u", PERSISTENCE_V5_QUEUE_KEY, qe->seqno);
@@ -684,29 +720,29 @@
 	int lens[MAX_NO_OF_BUFFERS];
 	void* bufs[MAX_NO_OF_BUFFERS];
 	int props_allocated = 0;
-		
+
 	FUNC_ENTRY;
 	bufs[bufindex] = &qe->msg->payloadlen;
 	lens[bufindex++] = sizeof(qe->msg->payloadlen);
-				
+
 	bufs[bufindex] = qe->msg->payload;
 	lens[bufindex++] = qe->msg->payloadlen;
-		
+
 	bufs[bufindex] = &qe->msg->qos;
 	lens[bufindex++] = sizeof(qe->msg->qos);
-		
+
 	bufs[bufindex] = &qe->msg->retained;
 	lens[bufindex++] = sizeof(qe->msg->retained);
-		
+
 	bufs[bufindex] = &qe->msg->dup;
 	lens[bufindex++] = sizeof(qe->msg->dup);
-				
+
 	bufs[bufindex] = &qe->msg->msgid;
 	lens[bufindex++] = sizeof(qe->msg->msgid);
-						
+
 	bufs[bufindex] = qe->topicName;
 	lens[bufindex++] = (int)strlen(qe->topicName) + 1;
-				
+
 	bufs[bufindex] = &qe->topicLen;
 	lens[bufindex++] = sizeof(qe->topicLen);
 
@@ -765,12 +801,12 @@
 	MQTTPersistence_qEntry* qe = NULL;
 	char* ptr = buffer;
 	int data_size;
-	
+
 	FUNC_ENTRY;
 	if ((qe = malloc(sizeof(MQTTPersistence_qEntry))) == NULL)
 		goto exit;
 	memset(qe, '\0', sizeof(MQTTPersistence_qEntry));
-	
+
 	if ((qe->msg = malloc(sizeof(MQTTPersistence_message))) == NULL)
 	{
 		free(qe);
@@ -778,12 +814,12 @@
 		goto exit;
 	}
 	memset(qe->msg, '\0', sizeof(MQTTPersistence_message));
-	
+
 	qe->msg->struct_version = 1;
 
 	qe->msg->payloadlen = *(int*)ptr;
 	ptr += sizeof(int);
-	
+
 	data_size = qe->msg->payloadlen;
 	if ((qe->msg->payload = malloc(data_size)) == NULL)
 	{
@@ -794,20 +830,20 @@
 	}
 	memcpy(qe->msg->payload, ptr, data_size);
 	ptr += data_size;
-	
+
 	qe->msg->qos = *(int*)ptr;
 	ptr += sizeof(int);
-	
+
 	qe->msg->retained = *(int*)ptr;
 	ptr += sizeof(int);
-	
+
 	qe->msg->dup = *(int*)ptr;
 	ptr += sizeof(int);
-	
+
 	qe->msg->msgid = *(int*)ptr;
 	ptr += sizeof(int);
-	
-	data_size = (int)strlen(ptr) + 1;	
+
+	data_size = (int)strlen(ptr) + 1;
 	if ((qe->topicName = malloc(data_size)) == NULL)
 	{
 		free(qe->msg->payload);
@@ -818,7 +854,7 @@
 	}
 	strcpy(qe->topicName, ptr);
 	ptr += data_size;
-	
+
 	qe->topicLen = *(int*)ptr;
 	ptr += sizeof(int);
 
@@ -868,7 +904,7 @@
 		{
 			char *buffer = NULL;
 			int buflen;
-					
+
 			if (strncmp(msgkeys[i], PERSISTENCE_QUEUE_KEY, strlen(PERSISTENCE_QUEUE_KEY)) != 0 &&
 				strncmp(msgkeys[i], PERSISTENCE_V5_QUEUE_KEY, strlen(PERSISTENCE_V5_QUEUE_KEY)) != 0)
 			{
@@ -881,9 +917,9 @@
 					(strncmp(msgkeys[i], PERSISTENCE_V5_QUEUE_KEY, strlen(PERSISTENCE_V5_QUEUE_KEY)) == 0)
 					? MQTTVERSION_5 : MQTTVERSION_3_1_1;
 				MQTTPersistence_qEntry* qe = MQTTPersistence_restoreQueueEntry(buffer, buflen, MQTTVersion);
-				
+
 				if (qe)
-				{	
+				{
 					qe->seqno = atoi(strchr(msgkeys[i], '-')+1); /* key format is tag'-'seqno */
 					MQTTPersistence_insertInSeqOrder(c->messageQueue, qe, sizeof(MQTTPersistence_qEntry));
 					c->qentry_seqno = max(c->qentry_seqno, qe->seqno);
diff -Naru paho.mqtt.c/src/MQTTProtocolClient.c paho.mqtt.c_new/src/MQTTProtocolClient.c
--- paho.mqtt.c/src/MQTTProtocolClient.c	2025-02-12 14:43:08.224065700 +0800
+++ paho.mqtt.c_new/src/MQTTProtocolClient.c	2025-02-12 14:11:54.430411500 +0800
@@ -177,18 +177,33 @@
 	if (qos > 0)
 	{
 		*mm = MQTTProtocol_createMessage(publish, mm, qos, retained, 0);
-		ListAppend(pubclient->outboundMsgs, *mm, (*mm)->len);
-		/* we change these pointers to the saved message location just in case the packet could not be written
-		entirely; the socket buffer will use these locations to finish writing the packet */
-		qos12pub.payload = (*mm)->publish->payload;
-		qos12pub.topic = (*mm)->publish->topic;
-		qos12pub.properties = (*mm)->properties;
-		qos12pub.MQTTVersion = (*mm)->MQTTVersion;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (*mm != NULL)
+		{
+#endif
+			ListAppend(pubclient->outboundMsgs, *mm, (*mm)->len);
+			/* we change these pointers to the saved message location just in case the packet could not be written
+			entirely; the socket buffer will use these locations to finish writing the packet */
+			qos12pub.payload = (*mm)->publish->payload;
+			qos12pub.topic = (*mm)->publish->topic;
+			qos12pub.properties = (*mm)->properties;
+			qos12pub.MQTTVersion = (*mm)->MQTTVersion;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		}
+		else
+		{
+			rc = PAHO_MEMORY_ERROR;
+			goto exit;
+		}
+#endif
 		publish = &qos12pub;
 	}
 	rc = MQTTProtocol_startPublishCommon(pubclient, publish, qos, retained);
 	if (qos > 0)
 		memcpy((*mm)->publish->mask, publish->mask, sizeof((*mm)->publish->mask));
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+exit:
+#endif
 	FUNC_EXIT_RC(rc);
 	return rc;
 }
@@ -218,6 +233,9 @@
 		if ((m->publish = MQTTProtocol_storePublication(publish, &len1)) == NULL)
 		{
 			free(m);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			m = NULL;
+#endif
 			goto exit;
 		}
 		m->len += len1;
@@ -228,6 +246,9 @@
 			if ((m->publish->payload = malloc(m->publish->payloadlen)) == NULL)
 			{
 				free(m);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+				m = NULL;
+#endif
 				goto exit;
 			}
 			memcpy(m->publish->payload, temp, m->publish->payloadlen);
@@ -242,6 +263,9 @@
 	m->qos = qos;
 	m->retain = retained;
 	m->MQTTVersion = publish->MQTTVersion;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	m->retryTime = 0;
+#endif
 	if (m->MQTTVersion >= 5)
 		m->properties = MQTTProperties_copy(&publish->properties);
 	m->lastTouch = MQTTTime_now();
@@ -331,8 +355,12 @@
 	FUNC_ENTRY;
 	client = (Clients*)(ListFindItem(bstate->clients, &sock, clientSocketCompare)->content);
 	clientid = client->clientID;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	Log(LOG_PROTOCOL, 11, NULL, sock, clientid, publish->msgId);
+#else
 	Log(LOG_PROTOCOL, 11, NULL, sock, clientid, publish->msgId, publish->header.bits.qos,
 					publish->header.bits.retain, publish->payloadlen, min(20, publish->payloadlen), publish->payload);
+#endif
 
 	if (publish->header.bits.qos == 0)
 	{
@@ -345,7 +373,7 @@
 	if (publish->header.bits.qos == 1)
 	{
 		Protocol_processPublication(publish, client, 1);
-  
+
 		if (socketHasPendingWrites)
 			rc = MQTTProtocol_queueAck(client, PUBACK, publish->msgId);
 		else
@@ -781,6 +809,36 @@
 	FUNC_EXIT;
 }
 
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+#define RETRYTIME 5
+static int MQTTProtocol_release(Clients* client, Messages* m)
+{
+	int ret = -1;
+	if (m->retryTime >= RETRYTIME)
+	{
+		if (ListFindItem(client->outboundMsgs, &(m->msgid), messageIDCompare) != NULL)
+		{
+			#if !defined(NO_PERSISTENCE)
+				rc = MQTTPersistence_remove(client,
+					(m->MQTTVersion >= MQTTVERSION_5) ? PERSISTENCE_V5_PUBLISH_SENT : PERSISTENCE_PUBLISH_SENT,
+					m->qos, m->msgid);
+			#endif
+			MQTTProtocol_removePublication(m->publish);
+			if (m->MQTTVersion >= MQTTVERSION_5)
+				MQTTProperties_free(&m->properties);
+			ListRemove(client->outboundMsgs, m);
+		}
+		client->retryMsgs = m->msgid;
+		ret = 0;
+	}
+	else
+	{
+		m->retryTime++;
+	}
+exit:
+	return ret;
+}
+#endif
 
 /**
  * MQTT retry processing per client
@@ -793,11 +851,11 @@
 	ListElement* outcurrent = NULL;
 
 	FUNC_ENTRY;
-
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 	if (!regardless && client->retryInterval <= 0 && /* 0 or -ive retryInterval turns off retry except on reconnect */
 			client->connect_sent == client->connect_count)
 		goto exit;
-
+#endif
 	if (regardless)
 		client->connect_count = client->outboundMsgs->count; /* remember the number of messages to retry on connect */
 	else if (client->connect_sent < client->connect_count) /* continue a connect retry which didn't complete first time around */
@@ -810,6 +868,11 @@
 		Messages* m = (Messages*)(outcurrent->content);
 		if (regardless || MQTTTime_difftime(now, m->lastTouch) > (DIFF_TIME_TYPE)(max(client->retryInterval, 10) * 1000))
 		{
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			if (MQTTProtocol_release(client, m) == 0)
+				goto exit;
+			Log(TRACE_MIN, -1, "%s, %d, msgid[%d]: retryTime = %d", __func__, __LINE__, m->msgid, m->retryTime);
+#endif
 			if (regardless)
 				++client->connect_sent;
 			if (m->qos == 1 || (m->qos == 2 && m->nextMessageType == PUBREC))
@@ -935,16 +998,38 @@
 	/* free up pending message lists here, and any other allocated data */
 	MQTTProtocol_freeMessageList(client->outboundMsgs);
 	MQTTProtocol_freeMessageList(client->inboundMsgs);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (client->messageQueue != NULL)
+		ListFree(client->messageQueue);
+	if (client->outboundQueue != NULL)
+		ListFree(client->outboundQueue);
+#else
 	ListFree(client->messageQueue);
 	ListFree(client->outboundQueue);
-	free(client->clientID);
-        client->clientID = NULL;
+#endif
+
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (client->clientID != NULL)
+	{
+#endif
+		free(client->clientID);
+		client->clientID = NULL;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	}
+#endif
 	if (client->will)
 	{
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (client->will->payload != NULL)
+			free(client->will->payload);
+		if (client->will->topic != NULL)
+			free(client->will->topic);
+#else
 		free(client->will->payload);
 		free(client->will->topic);
+#endif
 		free(client->will);
-                client->will = NULL;
+    	client->will = NULL;
 	}
 	if (client->username)
 		free((void*)client->username);
@@ -956,7 +1041,7 @@
 		free(client->httpsProxy);
 	if (client->net.http_proxy_auth)
 		free(client->net.http_proxy_auth);
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	if (client->net.https_proxy_auth)
 		free(client->net.https_proxy_auth);
 	if (client->sslopts)
@@ -982,7 +1067,7 @@
 				free((void*)client->sslopts->protos);
 		}
 		free(client->sslopts);
-			client->sslopts = NULL;
+		client->sslopts = NULL;
 	}
 #endif
 	/* don't free the client structure itself... this is done elsewhere */
@@ -1018,8 +1103,13 @@
 void MQTTProtocol_freeMessageList(List* msgList)
 {
 	FUNC_ENTRY;
-	MQTTProtocol_emptyMessageList(msgList);
-	ListFree(msgList);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if (msgList != NULL)
+	{
+		MQTTProtocol_emptyMessageList(msgList);
+		ListFree(msgList);
+	}
+#endif
 	FUNC_EXIT;
 }
 
diff -Naru paho.mqtt.c/src/MQTTProtocolOut.c paho.mqtt.c_new/src/MQTTProtocolOut.c
--- paho.mqtt.c/src/MQTTProtocolOut.c	2025-02-12 14:43:08.307888900 +0800
+++ paho.mqtt.c_new/src/MQTTProtocolOut.c	2025-02-12 14:11:54.430411500 +0800
@@ -3,11 +3,11 @@
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
- * and Eclipse Distribution License v1.0 which accompany this distribution. 
+ * and Eclipse Distribution License v1.0 which accompany this distribution.
  *
- * The Eclipse Public License is available at 
+ * The Eclipse Public License is available at
  *    https://www.eclipse.org/legal/epl-2.0/
- * and the Eclipse Distribution License is available at 
+ * and the Eclipse Distribution License is available at
  *   http://www.eclipse.org/org/documents/edl-v10.php.
  *
  * Contributors:
@@ -201,8 +201,8 @@
  * @param long timeout how long to wait for a new socket to be created
  * @return return code
  */
-#if defined(OPENSSL)
-#if defined(__GNUC__) && defined(__linux__)
+#if defined(OPENSSL) || defined(MBEDTLS)
+#if defined(__GNUC__) && defined(__linux__) && !defined(__LITEOS__)
 int MQTTProtocol_connect(const char* ip_address, Clients* aClient, int ssl, int websocket, int MQTTVersion,
 		MQTTProperties* connectProperties, MQTTProperties* willProperties, long timeout)
 #else
@@ -210,7 +210,7 @@
 		MQTTProperties* connectProperties, MQTTProperties* willProperties)
 #endif
 #else
-#if defined(__GNUC__) && defined(__linux__)
+#if defined(__GNUC__) && defined(__linux__) && !defined(__LITEOS__)
 int MQTTProtocol_connect(const char* ip_address, Clients* aClient, int websocket, int MQTTVersion,
 		MQTTProperties* connectProperties, MQTTProperties* willProperties, long timeout)
 #else
@@ -230,7 +230,11 @@
 	if (aClient->httpProxy)
 		p0 = aClient->httpProxy;
 	else
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		p0 = 0;
+#else
 		p0 = getenv("http_proxy");
+#endif
 
 	if (p0)
 	{
@@ -241,11 +245,15 @@
 			Log(TRACE_PROTOCOL, -1, "Setting http proxy auth to %s", aClient->net.http_proxy_auth);
 	}
 
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	if (aClient->httpsProxy)
 		p0 = aClient->httpsProxy;
 	else
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		p0 = 0;
+#else
 		p0 = getenv("https_proxy");
+#endif
 
 	if (p0)
 	{
@@ -261,7 +269,7 @@
 	if (aClient->net.http_proxy) {
 #endif
 		addr_len = MQTTProtocol_addressPort(aClient->net.http_proxy, &port, NULL, PROXY_DEFAULT_PORT);
-#if defined(__GNUC__) && defined(__linux__)
+#if defined(__GNUC__) && defined(__linux__) && !defined(__LITEOS__)
 		if (timeout < 0)
 			rc = -1;
 		else
@@ -270,10 +278,10 @@
 		rc = Socket_new(aClient->net.http_proxy, addr_len, port, &(aClient->net.socket));
 #endif
 	}
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	else if (ssl && aClient->net.https_proxy) {
 		addr_len = MQTTProtocol_addressPort(aClient->net.https_proxy, &port, NULL, PROXY_DEFAULT_PORT);
-#if defined(__GNUC__) && defined(__linux__)
+#if defined(__GNUC__) && defined(__linux__) && !defined(__LITEOS__)
 		if (timeout < 0)
 			rc = -1;
 		else
@@ -284,14 +292,14 @@
 	}
 #endif
 	else {
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 		addr_len = MQTTProtocol_addressPort(ip_address, &port, NULL, ssl ?
 				(websocket ? WSS_DEFAULT_PORT : SECURE_MQTT_DEFAULT_PORT) :
 				(websocket ? WS_DEFAULT_PORT : MQTT_DEFAULT_PORT) );
 #else
 		addr_len = MQTTProtocol_addressPort(ip_address, &port, NULL, websocket ? WS_DEFAULT_PORT : MQTT_DEFAULT_PORT);
 #endif
-#if defined(__GNUC__) && defined(__linux__)
+#if defined(__GNUC__) && defined(__linux__) && !defined(__LITEOS__)
 		if (timeout < 0)
 			rc = -1;
 		else
@@ -304,7 +312,7 @@
 		aClient->connect_state = TCP_IN_PROGRESS; /* TCP connect called - wait for connect completion */
 	else if (rc == 0)
 	{	/* TCP connect completed. If SSL, send SSL connect */
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 		if (ssl)
 		{
 			if (aClient->net.https_proxy) {
diff -Naru paho.mqtt.c/src/MQTTProtocolOut.h paho.mqtt.c_new/src/MQTTProtocolOut.h
--- paho.mqtt.c/src/MQTTProtocolOut.h	2025-02-12 14:43:08.350544900 +0800
+++ paho.mqtt.c_new/src/MQTTProtocolOut.h	2025-02-12 14:11:54.438411500 +0800
@@ -3,11 +3,11 @@
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
- * and Eclipse Distribution License v1.0 which accompany this distribution. 
+ * and Eclipse Distribution License v1.0 which accompany this distribution.
  *
- * The Eclipse Public License is available at 
+ * The Eclipse Public License is available at
  *    https://www.eclipse.org/legal/epl-2.0/
- * and the Eclipse Distribution License is available at 
+ * and the Eclipse Distribution License is available at
  *   http://www.eclipse.org/org/documents/edl-v10.php.
  *
  * Contributors:
@@ -38,8 +38,8 @@
 
 size_t MQTTProtocol_addressPort(const char* uri, int* port, const char **topic, int default_port);
 void MQTTProtocol_reconnect(const char* ip_address, Clients* client);
-#if defined(OPENSSL)
-#if defined(__GNUC__) && defined(__linux__)
+#if defined(OPENSSL) || defined(MBEDTLS)
+#if defined(__GNUC__) && defined(__linux__) && !defined(__LITEOS__)
 int MQTTProtocol_connect(const char* ip_address, Clients* acClients, int ssl, int websocket, int MQTTVersion,
 		MQTTProperties* connectProperties, MQTTProperties* willProperties, long timeout);
 #else
@@ -47,7 +47,7 @@
 		MQTTProperties* connectProperties, MQTTProperties* willProperties);
 #endif
 #else
-#if defined(__GNUC__) && defined(__linux__)
+#if defined(__GNUC__) && defined(__linux__) && !defined(__LITEOS__)
 int MQTTProtocol_connect(const char* ip_address, Clients* acClients, int websocket, int MQTTVersion,
 		MQTTProperties* connectProperties, MQTTProperties* willProperties, long timeout);
 #else
diff -Naru paho.mqtt.c/src/MQTTTime.c paho.mqtt.c_new/src/MQTTTime.c
--- paho.mqtt.c/src/MQTTTime.c	2025-02-12 14:43:08.510257700 +0800
+++ paho.mqtt.c_new/src/MQTTTime.c	2025-02-12 14:11:54.446411500 +0800
@@ -19,10 +19,15 @@
 
 #if defined(_WIN32) || defined(_WIN64)
 #include <windows.h>
+#elif defined(IOT_LITEOS_ADAPT)
+#include <time.h>
 #else
 #include <unistd.h>
 #include <sys/time.h>
 #endif
+#if defined(IOT_CONNECT)
+#include "atiny_mqtt_commu.h"
+#endif
 
 void MQTTTime_sleep(ELAPSED_TIME_TYPE milliseconds)
 {
diff -Naru paho.mqtt.c/src/mutex_type.h paho.mqtt.c_new/src/mutex_type.h
--- paho.mqtt.c/src/mutex_type.h	2025-02-12 14:43:08.616899000 +0800
+++ paho.mqtt.c_new/src/mutex_type.h	2025-02-12 14:11:54.478411500 +0800
@@ -17,6 +17,9 @@
 #if defined(_WIN32) || defined(_WIN64)
 	#include <windows.h>
 	#define mutex_type HANDLE
+#elif defined(COMPAT_CMSIS)
+    #include "cmsis_os2.h"
+    typedef osMutexId_t mutex_type;
 #else
 	#include <pthread.h>
 	#define mutex_type pthread_mutex_t*
diff -Naru paho.mqtt.c/src/SHA1.c paho.mqtt.c_new/src/SHA1.c
--- paho.mqtt.c/src/SHA1.c	2025-02-12 14:43:09.434309000 +0800
+++ paho.mqtt.c_new/src/SHA1.c	2025-02-12 14:11:54.458411500 +0800
@@ -59,7 +59,7 @@
 #  include <libkern/OSByteOrder.h>
 #  define htobe32(x) OSSwapHostToBigInt32(x)
 #  define be32toh(x) OSSwapBigToHostInt32(x)
-#elif defined(__FreeBSD__) || defined(__NetBSD__)
+#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
 #  include <sys/endian.h>
 #endif
 #include <string.h>
@@ -144,7 +144,11 @@
 	uint64_t total;
 
 	/* length before pad */
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	total = (uint64_t)ctx->total * 8;
+#else
 	total = ctx->total * 8;
+#endif
 
 	if ( ctx->size < 56 )
 		pad_amount = 56 - ctx->size;
diff -Naru paho.mqtt.c/src/Socket.c paho.mqtt.c_new/src/Socket.c
--- paho.mqtt.c/src/Socket.c	2025-02-12 14:43:09.539958700 +0800
+++ paho.mqtt.c_new/src/Socket.c	2025-02-12 14:11:54.462411500 +0800
@@ -33,7 +33,18 @@
 #include "SocketBuffer.h"
 #include "Messages.h"
 #include "StackTrace.h"
-#if defined(OPENSSL)
+#if defined(IOT_CONNECT)
+#include "soc_socket.h"
+#include "atiny_dns.h"
+#include "securec.h"
+#include "atiny_mqtt_commu.h"
+#endif
+
+#if defined(IOT_LITEOS_ADAPT)
+#include "lwip/sockets.h"
+#endif
+
+#if defined(OPENSSL) || defined(MBEDTLS)
 #include "SSLSocket.h"
 #endif
 
@@ -43,6 +54,10 @@
 #include <ctype.h>
 
 #include "Heap.h"
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+#define RETRY_TIMES 2
+#define RETRY_TIMEOUT_S 10
+#endif
 
 #if defined(USE_SELECT)
 int isReady(int socket, fd_set* read_set, fd_set* write_set);
@@ -83,6 +98,9 @@
  */
 int Socket_setnonblocking(SOCKET sock)
 {
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+    return 0;
+#else
 	int rc;
 #if defined(_WIN32) || defined(_WIN64)
 	u_long flag = 1L;
@@ -99,6 +117,7 @@
 #endif
 	FUNC_EXIT_RC(rc);
 	return rc;
+#endif
 }
 
 
@@ -120,16 +139,28 @@
 	if (err != EINTR && err != EAGAIN && err != EINPROGRESS && err != EWOULDBLOCK)
 	{
 		if (strcmp(aString, "shutdown") != 0 || (err != ENOTCONN && err != ECONNRESET))
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			Log(TRACE_MINIMUM, -1, "Socket error (%d) in %s for socket %d", err, aString, sock);
+#else
 			Log(TRACE_MINIMUM, -1, "Socket error %s(%d) in %s for socket %d", strerror(err), err, aString, sock);
+#endif
 	}
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	return -1;
+#else
 	return err;
+#endif
 }
 
 
 /**
  * Initialize the socket module
  */
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+int Socket_outInitialize(void)
+#else
 void Socket_outInitialize(void)
+#endif
 {
 #if defined(_WIN32) || defined(_WIN64)
 	WORD    winsockVer = 0x0202;
@@ -139,20 +170,53 @@
 	WSAStartup(winsockVer, &wsd);
 #else
 	FUNC_ENTRY;
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 	signal(SIGPIPE, SIG_IGN);
 #endif
+#endif
 
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	int rc;
+	rc = SocketBuffer_initialize();
+	if (rc != 0)
+		goto exit;
+#else
 	SocketBuffer_initialize();
+#endif
 	mod_s.connect_pending = ListInitialize();
 	mod_s.write_pending = ListInitialize();
-	
+
 #if defined(USE_SELECT)
 	mod_s.clientsds = ListInitialize();
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	if ((mod_s.clientsds == NULL) || (mod_s.connect_pending == NULL) || (mod_s.write_pending == NULL))
+	{
+		SocketBuffer_terminate();
+		if (mod_s.clientsds != NULL)
+		{
+			ListFree(mod_s.clientsds);
+			mod_s.clientsds = NULL;
+		}
+		if (mod_s.connect_pending != NULL)
+		{
+			ListFree(mod_s.connect_pending);
+			mod_s.connect_pending = NULL;
+		}
+		if (mod_s.write_pending != NULL)
+		{
+			ListFree(mod_s.write_pending);
+			mod_s.write_pending = NULL;
+		}
+		rc = PAHO_MEMORY_ERROR;
+		goto exit;
+	}
+#else
 	mod_s.cur_clientsds = NULL;
 	FD_ZERO(&(mod_s.rset));														/* Initialize the descriptor set */
 	FD_ZERO(&(mod_s.pending_wset));
 	mod_s.maxfdp1 = 0;
 	memcpy((void*)&(mod_s.rset_saved), (void*)&(mod_s.rset), sizeof(mod_s.rset_saved));
+#endif
 #else
 	mod_s.nfds = 0;
 	mod_s.fds_read = NULL;
@@ -163,7 +227,13 @@
 	mod_s.saved.fds_read = NULL;
 	mod_s.saved.nfds = 0;
 #endif
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+exit:
+	FUNC_EXIT_RC(rc);
+	return rc;
+#else
 	FUNC_EXIT;
+#endif
 }
 
 
@@ -236,7 +306,14 @@
 		}
 	}
 	else
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	{
+#endif
 		Log(LOG_ERROR, -1, "addSocket: socket %d already in the list", newSd);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		rc = 1;
+	}
+#endif
 
 exit:
 	FUNC_EXIT_RC(rc);
@@ -367,7 +444,6 @@
 }
 #endif
 
-
 #if defined(USE_SELECT)
 /**
  *  Returns the next socket ready for communications as indicated by select
@@ -379,7 +455,11 @@
  */
 SOCKET Socket_getReadySocket(int more_work, int timeout, mutex_type mutex, int* rc)
 {
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	SOCKET sock = SOCKET_ERROR;
+#else
 	SOCKET sock = 0;
+#endif
 	*rc = 0;
 	int timeout_ms = 1000;
 
@@ -387,7 +467,7 @@
 	Thread_lock_mutex(mutex);
 	if (mod_s.clientsds->count == 0)
 		goto exit;
-		
+
 	if (more_work)
 		timeout_ms = 0;
 	else if (timeout >= 0)
@@ -416,7 +496,7 @@
 		memcpy((void*)&(mod_s.rset), (void*)&(mod_s.rset_saved), sizeof(mod_s.rset));
 		memcpy((void*)&(pwset), (void*)&(mod_s.pending_wset), sizeof(pwset));
 		maxfdp1_saved = mod_s.maxfdp1;
-		
+
 		if (maxfdp1_saved == 0)
 		{
 			sock = 0;
@@ -424,7 +504,11 @@
 		}
 		/* Prevent performance issue by unlocking the socket_mutex while waiting for a ready socket. */
 		Thread_unlock_mutex(mutex);
+#if defined(IOT_CONNECT)
+		*rc = mqtt_select(maxfdp1_saved, &(mod_s.rset), &pwset, NULL, &timeout_tv);
+#else
 		*rc = select(maxfdp1_saved, &(mod_s.rset), &pwset, NULL, &timeout_tv);
+#endif
 		Thread_lock_mutex(mutex);
 		if (*rc == SOCKET_ERROR)
 		{
@@ -432,15 +516,31 @@
 			goto exit;
 		}
 		Log(TRACE_MAX, -1, "Return code %d from read select", *rc);
-
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		rc1 = Socket_continueWrites(&pwset, &sock, mutex);
+#if defined(SEND_MAX_LEN)
+        if (rc1 == SOCKET_ERROR || rc1 == EXT_SOCKET_RET_MESSAGE_TOO_LONG)
+#else
+        if (rc1 == SOCKET_ERROR)
+#endif
+		{
+			*rc = rc1;
+			goto exit;
+		}
+#else
 		if (Socket_continueWrites(&pwset, &sock, mutex) == SOCKET_ERROR)
 		{
 			*rc = SOCKET_ERROR;
 			goto exit;
 		}
+#endif
 
 		memcpy((void*)&wset, (void*)&(mod_s.rset_saved), sizeof(wset));
+#if defined(IOT_CONNECT)
+		if ((rc1 = mqtt_select(mod_s.maxfdp1, NULL, &(wset), NULL, &zero)) == SOCKET_ERROR)
+#else
 		if ((rc1 = select(mod_s.maxfdp1, NULL, &(wset), NULL, &zero)) == SOCKET_ERROR)
+#endif
 		{
 			Socket_error("write select", 0);
 			*rc = rc1;
@@ -450,7 +550,11 @@
 
 		if (*rc == 0 && rc1 == 0)
 		{
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			sock = SOCKET_ERROR;
+#else
 			sock = 0;
+#endif
 			goto exit; /* no work to do */
 		}
 
@@ -466,7 +570,13 @@
 
 	*rc = 0;
 	if (mod_s.cur_clientsds == NULL)
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	{
+		sock = SOCKET_ERROR;
+	}
+#else
 		sock = 0;
+#endif
 	else
 	{
 		sock = *((int*)(mod_s.cur_clientsds->content));
@@ -597,11 +707,20 @@
 	FUNC_ENTRY;
 	if ((rc = SocketBuffer_getQueuedChar(socket, c)) != SOCKETBUFFER_INTERRUPTED)
 		goto exit;
-
+#if defined(IOT_CONNECT)
+	if ((rc = adapt_recv(socket, c, (size_t)1, 0)) == SOCKET_ERROR)
+#elif defined(IOT_LITEOS_ADAPT)
+    if ((rc = lwip_recv(socket, c, (size_t)1, 0)) == SOCKET_ERROR)
+#else
 	if ((rc = recv(socket, c, (size_t)1, 0)) == SOCKET_ERROR)
+#endif
 	{
 		int err = Socket_error("recv - getch", socket);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (err == EWOULDBLOCK)
+#else
 		if (err == EWOULDBLOCK || err == EAGAIN)
+#endif
 		{
 			rc = TCPSOCKET_INTERRUPTED;
 			SocketBuffer_interrupted(socket, 0);
@@ -641,10 +760,20 @@
 
 	buf = SocketBuffer_getQueuedData(socket, bytes, actual_len);
 
+#if defined(IOT_CONNECT)
+	if ((*rc = adapt_recv(socket, buf + (*actual_len), (int)(bytes - (*actual_len)), 0)) == SOCKET_ERROR)
+#elif defined(IOT_LITEOS_ADAPT)
+    if ((*rc = lwip_recv(socket, buf + (*actual_len), (int)(bytes - (*actual_len)), 0)) == SOCKET_ERROR)
+#else
 	if ((*rc = recv(socket, buf + (*actual_len), (int)(bytes - (*actual_len)), 0)) == SOCKET_ERROR)
+#endif
 	{
 		*rc = Socket_error("recv - getdata", socket);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (*rc != EWOULDBLOCK)
+#else
 		if (*rc != EAGAIN && *rc != EWOULDBLOCK)
+#endif
 		{
 			buf = NULL;
 			goto exit;
@@ -734,11 +863,25 @@
 	else
 	{
 #endif
+#if defined(IOT_CONNECT)
+	rc = adapt_writev(socket, iovecs, count);
+#elif defined(IOT_LITEOS_ADAPT)
+    rc = lwip_writev(socket, iovecs, count);
+#else
 	rc = writev(socket, iovecs, count);
+#endif
+#if defined(SEND_MAX_LEN)
+	if (rc == SOCKET_ERROR || rc == EXT_SOCKET_RET_MESSAGE_TOO_LONG)
+#else
 	if (rc == SOCKET_ERROR)
+#endif
 	{
 		int err = Socket_error("writev - putdatas", socket);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (err == EWOULDBLOCK)
+#else
 		if (err == EWOULDBLOCK || err == EAGAIN)
+#endif
 			rc = TCPSOCKET_INTERRUPTED;
 	}
 	else
@@ -792,7 +935,16 @@
 		frees1[i+1] = bufs.frees[i];
 	}
 
+#if defined(IOT_CONNECT)
+	rc = Socket_writev(socket, iovecs, bufs.count+1, &bytes);
+#if defined(SEND_MAX_LEN)
+	if (rc != SOCKET_ERROR && rc != EXT_SOCKET_RET_MESSAGE_TOO_LONG && rc != EXT_SOCKET_RET_SLIDING_WINDOW_FULL)
+#else
+	if (rc != SOCKET_ERROR && rc != EXT_SOCKET_RET_SLIDING_WINDOW_FULL)
+#endif
+#else
 	if ((rc = Socket_writev(socket, iovecs, bufs.count+1, &bytes)) != SOCKET_ERROR)
+#endif
 	{
 		if (bytes == total)
 			rc = TCPSOCKET_COMPLETE;
@@ -805,9 +957,14 @@
 				rc = PAHO_MEMORY_ERROR;
 				goto exit;
 			}
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			Log(TRACE_MIN, -1, "Partial write: %lu bytes of %lu actually written on socket %d",
+					bytes, (unsigned long)total, socket);
+#else
 			Log(TRACE_MIN, -1, "Partial write: %lu bytes of %lu actually written on socket %d",
 					bytes, total, socket);
-#if defined(OPENSSL)
+#endif
+#if defined(OPENSSL) || defined(MBEDTLS)
 			SocketBuffer_pendingWrite(socket, NULL, bufs.count+1, iovecs, frees1, total, bytes);
 #else
 			SocketBuffer_pendingWrite(socket, bufs.count+1, iovecs, frees1, total, bytes);
@@ -874,11 +1031,25 @@
 	if ((rc = closesocket(socket)) == SOCKET_ERROR)
 		Socket_error("close", socket);
 #else
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 	if (shutdown(socket, SHUT_WR) == SOCKET_ERROR)
 		Socket_error("shutdown", socket);
+#endif
+#if defined(IOT_CONNECT)
+	if ((rc = adapt_recv(socket, NULL, (size_t)0, 0)) == SOCKET_ERROR)
+#elif defined(IOT_LITEOS_ADAPT)
+    if ((rc = lwip_recv(socket, NULL, (size_t)0, 0)) == SOCKET_ERROR)
+#else
 	if ((rc = recv(socket, NULL, (size_t)0, 0)) == SOCKET_ERROR)
+#endif
 		Socket_error("shutdown", socket);
+#if defined(IOT_CONNECT)
+	if ((rc = closesocket(socket, SOCK_CLOSE_FORCE_MODE)) == SOCKET_ERROR)
+#elif defined(IOT_LITEOS_ADAPT)
+    if ((rc = lwip_close(socket)) == SOCKET_ERROR)
+#else
 	if ((rc = close(socket)) == SOCKET_ERROR)
+#endif
 		Socket_error("close", socket);
 #endif
 	FUNC_EXIT_RC(rc);
@@ -1014,7 +1185,6 @@
 }
 #endif
 
-
 /**
  *  Create a new socket and TCP connect to an address/port
  *  @param addr the address string
@@ -1023,7 +1193,8 @@
  *  @param timeout the timeout in milliseconds
  *  @return completion code 0=good, SOCKET_ERROR=fail
  */
-#if defined(__GNUC__) && defined(__linux__)
+ #if !defined(IOT_CONNECT)
+#if defined(__GNUC__) && defined(__linux__) && !defined(__LITEOS__)
 int Socket_new(const char* addr, size_t addr_len, int port, SOCKET* sock, long timeout)
 #else
 int Socket_new(const char* addr, size_t addr_len, int port, SOCKET* sock)
@@ -1212,6 +1383,130 @@
 	FUNC_EXIT_RC(rc);
 	return rc;
 }
+#else /* IOT_CONNECT */
+int Socket_new(const char* addr, size_t addr_len, int port, SOCKET* sock)
+{
+	int mem_ret = -1;
+	int type = SOCK_STREAM;
+	char *addr_mem = NULL;
+	struct sockaddr_in address;
+	int rc = SOCKET_ERROR;
+	sa_family_t family = AF_INET;
+
+	FUNC_ENTRY;
+	*sock = SOCKET_ERROR;
+	mem_ret = memset_s(&address, sizeof(address), '\0', sizeof(address));
+	if (mem_ret != 0)
+	{
+		rc = PAHO_MEMORY_ERROR;
+		goto exit;
+	}
+
+	if (addr[0] == '[')
+	{
+		++addr;
+		--addr_len;
+	}
+
+	if ((addr_mem = malloc( addr_len + 1u )) == NULL)
+	{
+		rc = PAHO_MEMORY_ERROR;
+		goto exit;
+	}
+	memcpy( addr_mem, addr, addr_len );
+	addr_mem[addr_len] = '\0';
+
+	address.sin_family = family = AF_INET;
+	if (ipaddr_aton(addr_mem, (ip_addr_t *)&address.sin_addr) == 1)
+		rc = 0;
+	dns_attempts_cfg_t dns_attempt;
+	dns_attempt.max_attempts = RETRY_TIMES;
+	dns_attempt.wait_timeout = RETRY_TIMEOUT_S;
+	if (rc != 0 && atiny_dns_parse(addr_mem, &address.sin_addr, &dns_attempt) == 0)
+		rc = 0;
+	address.sin_port = port;
+
+	if (rc != 0)
+		Log(LOG_ERROR, -1, "%s is not a valid IP address", addr_mem);
+	else
+	{
+		if (address.sin_addr.type == IPADDR_TYPE_V6) {
+			address.sin_family = family = AF_INET6;
+		}
+
+		*sock =	(int)socket(family, type, TCP);
+		if (*sock < 0)
+			rc = Socket_error("socket", *sock);
+		else
+		{
+			Log(TRACE_MIN, -1, "New socket %d for %s, port %d",	*sock, addr, port);
+			rc = Socket_addSocket(*sock);
+			if (rc < 0)
+			{
+				rc = Socket_error("addSocket", *sock);
+			}
+			else if (rc > 0)
+			{
+				Socket_close_only(*sock);
+				*sock = -1;
+				rc = SOCKET_ERROR;
+				goto exit;
+			}
+			else
+			{
+				if (bind_callbacks(*sock, family) != 0)
+					Log(TRACE_MIN, -1, "%s,%d, bind fail.", __func__, __LINE__);
+				/* this could complete immediately, even though we are non-blocking */
+				rc = connect(*sock, (struct sockaddr*)&address, sizeof(address));
+				if (rc == 0)
+					rc = wait_connected(*sock);
+				else
+					rc = SOCKET_ERROR;
+				if (rc == SOCKET_ERROR)
+					rc = Socket_error("connect", *sock);
+				if (rc == EINPROGRESS || rc == EWOULDBLOCK)
+				{
+					SOCKET* pnewSd = (SOCKET*)malloc(sizeof(SOCKET));
+					ListElement* result = NULL;
+
+					if (!pnewSd)
+					{
+						rc = PAHO_MEMORY_ERROR;
+						goto exit;
+					}
+					*pnewSd = *sock;
+					Thread_lock_mutex(socket_mutex);
+					result = ListAppend(mod_s.connect_pending, pnewSd, sizeof(SOCKET));
+					Thread_unlock_mutex(socket_mutex);
+					if (!result)
+					{
+						free(pnewSd);
+						rc = PAHO_MEMORY_ERROR;
+						goto exit;
+					}
+					Log(TRACE_MIN, 15, "Connect pending");
+				}
+			}
+            /* Prevent socket leak by closing unusable sockets,
+               as reported in https://github.com/eclipse/paho.mqtt.c/issues/135 */
+            if (rc != 0 && (rc != EINPROGRESS) && (rc != EWOULDBLOCK))
+            {
+				Thread_lock_mutex(socket_mutex);
+            	Socket_close(*sock); /* close socket and remove from our list of sockets */
+				Thread_unlock_mutex(socket_mutex);
+                *sock = SOCKET_ERROR; /* as initialized before */
+            }
+		}
+	}
+
+exit:
+	if (addr_mem)
+		free(addr_mem);
+
+	FUNC_EXIT_RC(rc);
+	return rc;
+}
+#endif
 
 static Socket_writeContinue* writecontinue = NULL;
 
@@ -1251,7 +1546,7 @@
 	FUNC_ENTRY;
 	pw = SocketBuffer_getWrite(socket);
 
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	if (pw->ssl)
 	{
 		rc = SSLSocket_continueWrite(pw);
@@ -1277,7 +1572,16 @@
 		curbuflen += pw->iovecs[i].iov_len;
 	}
 
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	rc = Socket_writev(socket, iovecs1, curbuf+1, &bytes);
+#if defined(SEND_MAX_LEN)
+	if (rc != SOCKET_ERROR && rc != EXT_SOCKET_RET_MESSAGE_TOO_LONG)
+#else
+	if (rc != SOCKET_ERROR)
+#endif
+#else
 	if ((rc = Socket_writev(socket, iovecs1, curbuf+1, &bytes)) != SOCKET_ERROR)
+#endif
 	{
 		pw->bytes += bytes;
 		if ((rc = (pw->bytes == pw->total)))
@@ -1310,7 +1614,7 @@
             }
 		}
 	}
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 exit:
 #endif
 	FUNC_EXIT_RC(rc);
@@ -1333,10 +1637,12 @@
 	if ((pw = SocketBuffer_getWrite(socket)) == NULL)
 	  goto exit;
 
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	if (pw->ssl)
 	{
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 		rc = SSLSocket_abortWrite(pw);
+#endif
 		goto exit;
 	}
 #endif
@@ -1366,7 +1672,7 @@
 #else
 /**
  *  Continue any outstanding socket writes
- 
+
  *  @param sock in case of a socket error contains the affected socket
  *  @return completion code, 0 or SOCKET_ERROR
  */
@@ -1421,10 +1727,18 @@
 		if (writecontinue && rc == 0)
 			(*writecontinue)(socket);
 
-		if (rc == SOCKET_ERROR)
+#if defined(SEND_MAX_LEN)
+		if (rc == SOCKET_ERROR || rc == EXT_SOCKET_RET_MESSAGE_TOO_LONG)
+#else
+		if(rc == SOCKET_ERROR)
+#endif
 		{
 			*sock = socket;
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			rc1 = rc;
+#else
 			rc1 = SOCKET_ERROR;
+#endif
 		}
 	}
 	FUNC_EXIT_RC(rc1);
@@ -1478,6 +1792,9 @@
  */
 char* Socket_getpeer(SOCKET sock)
 {
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	return "unknown";
+#else
 	struct sockaddr_in6 sa;
 	socklen_t sal = sizeof(sa);
 
@@ -1488,6 +1805,7 @@
 	}
 
 	return Socket_getaddrname((struct sockaddr*)&sa, sock);
+#endif
 }
 
 
diff -Naru paho.mqtt.c/src/Socket.h paho.mqtt.c_new/src/Socket.h
--- paho.mqtt.c/src/Socket.h	2025-02-12 14:43:09.580133800 +0800
+++ paho.mqtt.c_new/src/Socket.h	2025-02-12 14:11:54.462411500 +0800
@@ -18,8 +18,10 @@
 #if !defined(SOCKET_H)
 #define SOCKET_H
 
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 #include <stdint.h>
 #include <sys/types.h>
+#endif
 
 #if defined(_WIN32) || defined(_WIN64)
 #include <errno.h>
@@ -49,23 +51,33 @@
 #define INVALID_SOCKET SOCKET_ERROR
 #include <sys/socket.h>
 #if !defined(_WRS_KERNEL)
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 #include <sys/param.h>
+#endif
 #include <sys/time.h>
 #include <sys/select.h>
 #include <poll.h>
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 #include <sys/uio.h>
+#endif
 #else
 #include <selectLib.h>
 #endif
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 #include <arpa/inet.h>
 #include <netdb.h>
 #include <stdio.h>
 #include <unistd.h>
-#include <errno.h>
 #include <fcntl.h>
 #include <unistd.h>
+#endif
+#include <errno.h>
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+extern int errno;
+#define USE_SELECT 1
+#endif
 #define ULONG size_t
 #define SOCKET int
 #endif
@@ -135,15 +147,18 @@
 #endif
 } Sockets;
 
-
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT) 
+int Socket_outInitialize(void);
+#else
 void Socket_outInitialize(void);
+#endif
 void Socket_outTerminate(void);
 SOCKET Socket_getReadySocket(int more_work, int timeout, mutex_type mutex, int* rc);
 int Socket_getch(SOCKET socket, char* c);
 char *Socket_getdata(SOCKET socket, size_t bytes, size_t* actual_len, int* rc);
 int Socket_putdatas(SOCKET socket, char* buf0, size_t buf0len, PacketBuffers bufs);
 int Socket_close(SOCKET socket);
-#if defined(__GNUC__) && defined(__linux__)
+#if defined(__GNUC__) && defined(__linux__) && !defined(__LITEOS__)
 /* able to use GNU's getaddrinfo_a to make timeouts possible */
 int Socket_new(const char* addr, size_t addr_len, int port, SOCKET* socket, long timeout);
 #else
diff -Naru paho.mqtt.c/src/SocketBuffer.c paho.mqtt.c_new/src/SocketBuffer.c
--- paho.mqtt.c/src/SocketBuffer.c	2025-02-12 14:43:09.612869700 +0800
+++ paho.mqtt.c_new/src/SocketBuffer.c	2025-02-12 14:11:54.462411500 +0800
@@ -87,10 +87,22 @@
 		def_queue->buf = malloc(def_queue->buflen);
 		if (def_queue->buf)
 		{
+#if defined(ZERO_SOCK_FD_IS_INVALID)
 			def_queue->socket = def_queue->index = 0;
+#else
+			def_queue->socket = -1;
+			def_queue->index = 0;
+#endif
 			def_queue->buflen = def_queue->datalen = def_queue->headerlen = 0;
 			rc = 0;
 		}
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		else
+		{
+			free(def_queue);
+			def_queue = NULL;
+		}
+#endif
 	}
 	return rc;
 }
@@ -108,7 +120,14 @@
 	if (rc == 0)
 	{
 		if ((queues = ListInitialize()) == NULL)
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		{
+			SocketBuffer_freeDefQ();
+			rc = PAHO_MEMORY_ERROR;
+		}
+#else
 			rc = PAHO_MEMORY_ERROR;
+#endif
 	}
 	ListZero(&writes);
 	FUNC_EXIT_RC(rc);
@@ -123,7 +142,7 @@
 {
 	free(def_queue->buf);
 	free(def_queue);
-        def_queue = NULL;
+	def_queue = NULL;
 }
 
 
@@ -159,7 +178,12 @@
 	}
 	if (def_queue->socket == socket)
 	{
+#if defined(ZERO_SOCK_FD_IS_INVALID)
 		def_queue->socket = def_queue->index = 0;
+#else
+		def_queue->socket = -1;
+		def_queue->index = 0;
+#endif
 		def_queue->headerlen = def_queue->datalen = 0;
 	}
 	FUNC_EXIT;
@@ -201,8 +225,10 @@
 			}
 			else
 			{
+#if !defined(IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
 				free(queue->buf);
 				queue->buf = NULL;
+#endif
 				goto exit;
 			}
 		}
@@ -294,7 +320,12 @@
 		def_queue = queue;
 		ListDetach(queues, queue);
 	}
+#if defined(ZERO_SOCK_FD_IS_INVALID)
 	def_queue->socket = def_queue->index = 0;
+#else
+	def_queue->socket = -1;
+	def_queue->index = 0;
+#endif
 	def_queue->headerlen = def_queue->datalen = 0;
 	FUNC_EXIT;
 	return def_queue->buf;
@@ -314,7 +345,11 @@
 	FUNC_ENTRY;
 	if (ListFindItem(queues, &socket, socketcompare))
 		curq = (socket_queue*)(queues->current->content);
+#if defined(ZERO_SOCK_FD_IS_INVALID)
 	else if (def_queue->socket == 0)
+#else
+	else if (def_queue->socket == -1)
+#endif
 	{
 		def_queue->socket = socket;
 		def_queue->index = 0;
@@ -349,7 +384,7 @@
  * @param total total data length to be written
  * @param bytes actual data length that was written
  */
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 int SocketBuffer_pendingWrite(SOCKET socket, SSL* ssl, int count, iobuf* iovecs, int* frees, size_t total, size_t bytes)
 #else
 int SocketBuffer_pendingWrite(SOCKET socket, int count, iobuf* iovecs, int* frees, size_t total, size_t bytes)
@@ -367,7 +402,7 @@
 		goto exit;
 	}
 	pw->socket = socket;
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	pw->ssl = ssl;
 #endif
 	pw->bytes = bytes;
diff -Naru paho.mqtt.c/src/SocketBuffer.h paho.mqtt.c_new/src/SocketBuffer.h
--- paho.mqtt.c/src/SocketBuffer.h	2025-02-12 14:43:09.647095000 +0800
+++ paho.mqtt.c_new/src/SocketBuffer.h	2025-02-12 14:11:54.462411500 +0800
@@ -3,11 +3,11 @@
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
- * and Eclipse Distribution License v1.0 which accompany this distribution. 
+ * and Eclipse Distribution License v1.0 which accompany this distribution.
  *
- * The Eclipse Public License is available at 
+ * The Eclipse Public License is available at
  *    https://www.eclipse.org/legal/epl-2.0/
- * and the Eclipse Distribution License is available at 
+ * and the Eclipse Distribution License is available at
  *   http://www.eclipse.org/org/documents/edl-v10.php.
  *
  * Contributors:
@@ -23,7 +23,9 @@
 #if defined(OPENSSL)
 #include <openssl/ssl.h>
 #endif
-
+#if defined(MBEDTLS)
+#include "Clients.h"
+#endif
 #if defined(_WIN32) || defined(_WIN64)
 	typedef WSABUF iobuf;
 #else
@@ -46,7 +48,7 @@
 	SOCKET socket;
 	int count;
 	size_t total;
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	SSL* ssl;
 #endif
 	size_t bytes;
@@ -69,7 +71,7 @@
 char* SocketBuffer_complete(SOCKET socket);
 void SocketBuffer_queueChar(SOCKET socket, char c);
 
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 int SocketBuffer_pendingWrite(SOCKET socket, SSL* ssl, int count, iobuf* iovecs, int* frees, size_t total, size_t bytes);
 #else
 int SocketBuffer_pendingWrite(SOCKET socket, int count, iobuf* iovecs, int* frees, size_t total, size_t bytes);
diff -Naru paho.mqtt.c/src/SSLSocket.c paho.mqtt.c_new/src/SSLSocket.c
--- paho.mqtt.c/src/SSLSocket.c	2025-02-12 14:43:09.684791900 +0800
+++ paho.mqtt.c_new/src/SSLSocket.c	2025-02-12 14:11:54.458411500 +0800
@@ -348,6 +348,9 @@
 	FUNC_ENTRY;
 #if defined(_WIN32) || defined(_WIN64)
 	*mutex = CreateMutex(NULL, 0, NULL);
+#elif defined(COMPAT_CMSIS)
+	*mutex = osMutexNew(NULL);
+	rc = (*mutex == NULL) ? -1 : 0;
 #else
 	rc = pthread_mutex_init(mutex, NULL);
 #endif
@@ -362,6 +365,8 @@
 	/* don't add entry/exit trace points, as trace gets lock too, and it might happen quite frequently  */
 #if defined(_WIN32) || defined(_WIN64)
 	if (WaitForSingleObject(*mutex, INFINITE) != WAIT_FAILED)
+#elif defined(COMPAT_CMSIS)
+	if ((rc = osMutexAcquire(*mutex, osWaitForever)) == osOK)
 #else
 	if ((rc = pthread_mutex_lock(mutex)) == 0)
 #endif
@@ -377,6 +382,8 @@
 	/* don't add entry/exit trace points, as trace gets lock too, and it might happen quite frequently  */
 #if defined(_WIN32) || defined(_WIN64)
 	if (ReleaseMutex(*mutex) != 0)
+#elif defined (COMPAT_CMSIS)
+	if ((rc = osMutexRelease(*mutex)) == osOK)
 #else
 	if ((rc = pthread_mutex_unlock(mutex)) == 0)
 #endif
@@ -391,7 +398,11 @@
 
 	FUNC_ENTRY;
 #if defined(_WIN32) || defined(_WIN64)
-	rc = CloseHandle(*mutex);
+	if (*mutex != NULL)
+		rc = CloseHandle(*mutex);
+#elif defined(COMPAT_CMSIS)
+	if (*mutex != NULL)
+		rc = osMutexDelete(*mutex);
 #else
 	rc = pthread_mutex_destroy(mutex);
 #endif
@@ -593,10 +604,12 @@
 		}
 	}
 
+
 #if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
 	SSL_CTX_set_security_level(net->ctx, 1);
 #endif
 
+
 	if (opts->keyStore)
 	{
 		if ((rc = SSL_CTX_use_certificate_chain_file(net->ctx, opts->keyStore)) != 1)
@@ -1040,7 +1053,7 @@
 		    	free(bufs.buffers[i]);
 		    	bufs.buffers[i] = NULL;
 		    }
-		}	
+		}
 	}
 exit:
 	FUNC_EXIT_RC(rc);
diff -Naru paho.mqtt.c/src/SSLSocket.h paho.mqtt.c_new/src/SSLSocket.h
--- paho.mqtt.c/src/SSLSocket.h	2025-02-12 14:43:09.722487300 +0800
+++ paho.mqtt.c_new/src/SSLSocket.h	2025-02-12 14:11:54.458411500 +0800
@@ -3,15 +3,15 @@
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
- * and Eclipse Distribution License v1.0 which accompany this distribution. 
+ * and Eclipse Distribution License v1.0 which accompany this distribution.
  *
- * The Eclipse Public License is available at 
+ * The Eclipse Public License is available at
  *    https://www.eclipse.org/legal/epl-2.0/
- * and the Eclipse Distribution License is available at 
+ * and the Eclipse Distribution License is available at
  *   http://www.eclipse.org/org/documents/edl-v10.php.
  *
  * Contributors:
- *    Ian Craggs, Allan Stockdill-Mander - initial implementation 
+ *    Ian Craggs, Allan Stockdill-Mander - initial implementation
  *    Ian Craggs - SNI support
  *    Ian Craggs - post connect checks and CApath
  *******************************************************************************/
@@ -20,13 +20,18 @@
 
 #if defined(_WIN32) || defined(_WIN64)
 	#define ssl_mutex_type HANDLE
+#elif defined(COMPAT_CMSIS)
+	#include "cmsis_os2.h"
+	typedef osMutexId_t ssl_mutex_type;
 #else
 	#include <pthread.h>
 	#include <semaphore.h>
 	#define ssl_mutex_type pthread_mutex_t
 #endif
 
+#if defined(OPENSSL)
 #include <openssl/ssl.h>
+#endif
 #include "SocketBuffer.h"
 #include "Clients.h"
 
diff -Naru paho.mqtt.c/src/SSLSocket_mbedtls.c paho.mqtt.c_new/src/SSLSocket_mbedtls.c
--- paho.mqtt.c/src/SSLSocket_mbedtls.c	1970-01-01 08:00:00.000000000 +0800
+++ paho.mqtt.c_new/src/SSLSocket_mbedtls.c	2025-02-12 14:11:54.462411500 +0800
@@ -0,0 +1,901 @@
+/*
+ * Copyright (c) CompanyNameMagicTag
+ * Description: Mbedtls Adaptation Layer of MQTT
+ * Author: LiteOS Team
+ * Create: 2020-08-10
+ */
+#if defined(MBEDTLS)
+
+#include "SocketBuffer.h"
+#include "MQTTClient.h"
+#include "MQTTProtocolOut.h"
+#include "SSLSocket.h"
+#include "Log.h"
+#include "StackTrace.h"
+#include "Socket.h"
+
+#include "Heap.h"
+
+#include "securec.h"
+
+#if defined(IOT_CONNECT)
+#include "atiny_mqtt_commu.h"
+#include "soc_socket.h"
+#endif
+
+#include <string.h>
+#include <mbedtls/ctr_drbg.h>
+#include <mbedtls/entropy.h>
+#include <mbedtls/ssl.h>
+#include <mbedtls/x509.h>
+#include <mbedtls/net_sockets.h>
+#include <mbedtls/platform.h>
+#if !defined(IOT_LITEOS_ADAPT)
+#include <ssl_misc.h>
+#endif
+
+extern Sockets mod_s;
+static ssl_mutex_type sslCoreMutex;
+
+static int SSL_create_mutex(ssl_mutex_type* mutex);
+static int SSL_lock_mutex(ssl_mutex_type* mutex);
+static int SSL_unlock_mutex(ssl_mutex_type* mutex);
+static void SSL_destroy_mutex(ssl_mutex_type* mutex);
+static int SSLSocket_createContext(networkHandles* net, MQTTClient_SSLOptions* opts);
+static void SSLSocket_destroyContext(networkHandles* net);
+static void SSLSocket_addPendingRead(int sock);
+
+#if defined(WIN32) || defined(WIN64)
+#define iov_len len
+#define iov_base buf
+#endif
+
+
+#if !defined(ARRAY_SIZE)
+/**
+ * Macro to calculate the number of entries in an array
+ */
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+#endif
+
+#if defined(SEND_MAX_LEN)
+#define LOG_LEN 150
+#define SSL_HEADER_LEN 64
+#endif
+
+static int SSL_create_mutex(ssl_mutex_type* mutex)
+{
+	int rc = 0;
+	if (mutex == NULL)
+		return -1;
+
+	FUNC_ENTRY;
+#if defined(WIN32) || defined(WIN64)
+	*mutex = CreateMutex(NULL, 0, NULL);
+#elif defined(COMPAT_CMSIS)
+	*mutex = osMutexNew(NULL);
+	rc = (*mutex == NULL) ? -1 : 0;
+#else
+	rc = pthread_mutex_init(mutex, NULL);
+#endif
+	FUNC_EXIT_RC(rc);
+	return rc;
+}
+
+static int SSL_lock_mutex(ssl_mutex_type* mutex)
+{
+	int rc = -1;
+	if (mutex == NULL)
+		return rc;
+
+	/* don't add entry/exit trace points, as trace gets lock too, and it might happen quite frequently  */
+#if defined(WIN32) || defined(WIN64)
+	if (WaitForSingleObject(*mutex, INFINITE) != WAIT_FAILED)
+#elif defined(COMPAT_CMSIS)
+	if ((rc = osMutexAcquire(*mutex, osWaitForever)) == osOK)
+#else
+	if ((rc = pthread_mutex_lock(mutex)) == 0)
+#endif
+		rc = 0;
+
+	return rc;
+}
+
+static int SSL_unlock_mutex(ssl_mutex_type* mutex)
+{
+	int rc = -1;
+	if (mutex == NULL)
+		return rc;
+
+	/* don't add entry/exit trace points, as trace gets lock too, and it might happen quite frequently  */
+#if defined(WIN32) || defined(WIN64)
+	if (ReleaseMutex(*mutex) != 0)
+#elif defined (COMPAT_CMSIS)
+	if ((rc = osMutexRelease(*mutex)) == osOK)
+#else
+	if ((rc = pthread_mutex_unlock(mutex)) == 0)
+#endif
+		rc = 0;
+
+	return rc;
+}
+
+static void SSL_destroy_mutex(ssl_mutex_type* mutex)
+{
+	int rc = 0;
+	if (mutex == NULL)
+		return;
+
+	FUNC_ENTRY;
+#if defined(WIN32) || defined(WIN64)
+	if (*mutex != NULL)
+		rc = CloseHandle(*mutex);
+#elif defined(COMPAT_CMSIS)
+	if (*mutex != NULL)
+		rc = osMutexDelete(*mutex);
+#else
+	rc = pthread_mutex_destroy(mutex);
+#endif
+	FUNC_EXIT_RC(rc);
+}
+
+#ifdef MBEDTLS_USE_CRT
+/*
+ * custom verify on mbedtls, when ssl option verify is not set.
+ */
+static int SSL_verify_discard(void* data, mbedtls_x509_crt* crt, int depth, uint32_t* flags)
+{
+	char buf[512];
+	((void) data);
+	(void)crt;
+	(void)depth;
+	if (flags != NULL && (*flags) != 0)
+	{
+		mbedtls_x509_crt_verify_info(buf, sizeof(buf), NULL, *flags);
+		Log(TRACE_PROTOCOL, 1,  "Warnning! flags:%u %s", *flags, buf);
+
+		/* Discard CN mismatch when ssl options verify unset */
+		if (*flags == MBEDTLS_X509_BADCERT_CN_MISMATCH)
+			*flags = 0;
+	}
+
+	return 0;
+}
+#endif
+
+void SSLSocket_handleOpensslInit(int bool_value)
+{
+	(void)bool_value;
+	return;
+}
+
+
+int SSLSocket_initialize(void)
+{
+	int rc = 0;
+	FUNC_ENTRY;
+
+	SSL_create_mutex(&sslCoreMutex);
+
+	FUNC_EXIT_RC(rc);
+	return rc;
+}
+
+void SSLSocket_terminate(void)
+{
+	FUNC_ENTRY;
+
+	SSL_destroy_mutex(&sslCoreMutex);
+
+	FUNC_EXIT;
+}
+
+static int SSL_loadClientCrt(networkHandles* net, const MQTTClient_SSLOptions* opts)
+{
+	int rc;
+#if !defined (IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
+	if (opts->keyStore != NULL && opts->privateKey != NULL)
+#else
+	if (opts->los_keyStore != NULL && opts->los_privateKey != NULL)
+#endif
+	{
+		/* parse client cert */
+#if !defined (IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
+		rc = mbedtls_x509_crt_parse_file(&net->ctx->clicert, opts->keyStore);
+#else
+		rc = mbedtls_x509_crt_parse( &net->ctx->clicert, opts->los_keyStore->body, opts->los_keyStore->size );
+#endif
+		if (rc != 0)
+		{
+			Log(TRACE_PROTOCOL, -1, "failed ! mbedtls_x509_crt_parse_file");
+			return rc;
+		}
+
+		/* parse client key */
+#if !defined (IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
+		rc = mbedtls_pk_parse_keyfile(&net->ctx->pkey, opts->privateKey, opts->privateKeyPassword);
+#else
+		if (opts->privateKeyPassword == NULL)
+			rc = mbedtls_pk_parse_key( &net->ctx->pkey, opts->los_privateKey->body, opts->los_privateKey->size, NULL, 0,
+				NULL, NULL);
+		else
+			rc = mbedtls_pk_parse_key( &net->ctx->pkey, opts->los_privateKey->body, opts->los_privateKey->size,
+				(const unsigned char *) opts->privateKeyPassword, strlen( opts->privateKeyPassword ), NULL, NULL);
+#endif
+		if (rc != 0)
+		{
+			Log(TRACE_PROTOCOL, -1, "failed ! mbedtls_pk_parse_keyfile");
+			return rc;
+		}
+
+		/* config own cert */
+		rc = mbedtls_ssl_conf_own_cert(&net->ctx->conf, &net->ctx->clicert, &net->ctx->pkey);
+		if (rc != 0)
+		{
+			Log(TRACE_PROTOCOL, -1, "failed ! mbedtls_ssl_conf_own_cert");
+			return rc;
+		}
+	}
+	return 0;
+}
+
+static int SSL_loadKey(networkHandles* net, const MQTTClient_SSLOptions* opts)
+{
+	int rc;
+#ifdef MBEDTLS_USE_PSK
+	rc = mbedtls_ssl_conf_psk(&net->ctx->conf, opts->psk, opts->psk_len, opts->psk_id, opts->psk_id_len);
+	if (rc != 0)
+	{
+		Log(TRACE_PROTOCOL, -1, "failed ! mbedtls_ssl_conf_psk");
+		return rc;
+	}
+#endif /* MBEDTLS_USE_PSK */
+
+#ifdef MBEDTLS_USE_CRT
+	rc = SSL_loadClientCrt(net, opts);
+	if (rc != 0) {
+		return rc;
+	}
+
+#if !defined (IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
+	if (opts->trustStore != NULL)
+#else
+	if (opts->los_trustStore != NULL)
+#endif
+	{
+		/* parse CA file */
+#if !defined (IOT_CONNECT) && !defined(IOT_LITEOS_ADAPT)
+		rc = mbedtls_x509_crt_parse_file(&net->ctx->cacert, opts->trustStore);
+#else
+		rc = mbedtls_x509_crt_parse( &net->ctx->cacert, opts->los_trustStore->body, opts->los_trustStore->size );
+#endif
+		if (rc != 0)
+		{
+			Log(TRACE_PROTOCOL, -1, "failed ! mbedtls_x509_crt_parse_file");
+			return rc;
+		}
+		/* set the ca certificate chain */
+		mbedtls_ssl_conf_ca_chain(&net->ctx->conf, &net->ctx->cacert, NULL);
+	}
+
+	if (opts->enableServerCertAuth != 0)
+		mbedtls_ssl_conf_authmode(&net->ctx->conf, MBEDTLS_SSL_VERIFY_REQUIRED);
+	else
+		mbedtls_ssl_conf_authmode(&net->ctx->conf, MBEDTLS_SSL_VERIFY_NONE);
+
+	/* custom mbedtls verify */
+	if (opts->verify == 0)
+		mbedtls_ssl_conf_verify(&net->ctx->conf, SSL_verify_discard, NULL);
+#endif /* MBEDTLS_USE_CRT */
+	return 0;
+}
+
+static void SSL_setVersion(networkHandles* net, const MQTTClient_SSLOptions* opts)
+{
+	int sslVersion = MQTT_SSL_VERSION_DEFAULT;
+	if (opts->struct_version >= 1)
+		sslVersion = opts->sslVersion;
+	switch (sslVersion)
+	{
+	case MQTT_SSL_VERSION_DEFAULT:
+		break;
+#if !defined(IOT_LITEOS_ADAPT)
+	case MQTT_SSL_VERSION_TLS_1_0:
+		mbedtls_ssl_conf_min_version(&net->ctx->conf, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_1);
+		mbedtls_ssl_conf_max_version(&net->ctx->conf, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_1);
+		break;
+	case MQTT_SSL_VERSION_TLS_1_1:
+		mbedtls_ssl_conf_min_version(&net->ctx->conf, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_2);
+		mbedtls_ssl_conf_max_version(&net->ctx->conf, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_2);
+		break;
+#endif
+	case MQTT_SSL_VERSION_TLS_1_2:
+		mbedtls_ssl_conf_min_version(&net->ctx->conf, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_3);
+		mbedtls_ssl_conf_max_version(&net->ctx->conf, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_3);
+		break;
+	default:
+		break;
+	}
+}
+
+static int SSL_tlsInit(networkHandles* net, const MQTTClient_SSLOptions* opts)
+{
+	int rc = 0;
+	/* RNG related string */
+	static const char personalization[] = "paho_mbedtls_entropy";
+
+	net->ctx = (SSL_CTX*)malloc(sizeof(SSL_CTX));
+	if (net->ctx == NULL)
+	{
+		Log(TRACE_PROTOCOL, -1, "allocate context failed.");
+		return PAHO_MEMORY_ERROR;
+	}
+
+	/* initialise the mbedtls context */
+	mbedtls_ssl_config_init(&net->ctx->conf);
+	/* initialise RNG */
+	mbedtls_entropy_init(&net->ctx->entropy);
+	mbedtls_ctr_drbg_init(&net->ctx->ctr_drbg);
+#ifdef MBEDTLS_USE_CRT
+	/* init certificates */
+	mbedtls_x509_crt_init(&net->ctx->cacert);
+	mbedtls_x509_crt_init(&net->ctx->clicert);
+	mbedtls_pk_init(&net->ctx->pkey);
+#endif /* MBEDTLS_USE_CRT */
+	if ((rc = mbedtls_ctr_drbg_seed(
+			&net->ctx->ctr_drbg, mbedtls_entropy_func,
+			&net->ctx->entropy, (const unsigned char*)personalization,
+				sizeof(personalization))) != 0)
+	{
+		Log(TRACE_PROTOCOL, -1, "failed ! mbedtls_ctr_drbg_seed returned %d", rc);
+		SSLSocket_destroyContext(net);
+		return rc;
+	}
+
+	mbedtls_ssl_conf_rng(&net->ctx->conf, mbedtls_ctr_drbg_random,
+							&net->ctx->ctr_drbg);
+
+	/* load default config */
+	if ((rc = mbedtls_ssl_config_defaults(&net->ctx->conf,
+			MBEDTLS_SSL_IS_CLIENT,
+			MBEDTLS_SSL_TRANSPORT_STREAM,
+			MBEDTLS_SSL_PRESET_DEFAULT)) != 0)
+	{
+		Log(TRACE_PROTOCOL, -1, "failed ! mbedtls_ssl_config_defaults returned %d", rc);
+		SSLSocket_destroyContext(net);
+		return rc;
+	}
+
+	SSL_setVersion(net, opts);
+
+	return rc;
+}
+
+int SSLSocket_createContext(networkHandles* net, MQTTClient_SSLOptions* opts)
+{
+	int rc = 0;
+
+	FUNC_ENTRY;
+	if (net->ctx == NULL)
+	{
+		rc = SSL_tlsInit(net, opts);
+		if (rc != 0)
+			goto exit;
+
+	}
+
+	rc = SSL_loadKey(net, opts);
+	if (rc != 0)
+		SSLSocket_destroyContext(net);
+
+exit:
+	FUNC_EXIT_RC(rc);
+	return rc;
+}
+
+#define SSL_MAX_COUNT 65535
+/**
+ * SSLSocket_setSocketForSSL
+ * @return 0 is failure, 1 is success
+ */
+int SSLSocket_setSocketForSSL(networkHandles* net, MQTTClient_SSLOptions* opts,
+	const char* hostname, size_t hostname_len)
+{
+	int rc = 0;
+	int ret_state = 0;
+
+	if (net == NULL || opts == NULL || hostname == NULL)
+		goto exit;
+	if (hostname_len > SSL_MAX_COUNT)
+		goto exit;
+
+	FUNC_ENTRY;
+	if (net->ctx != NULL || (ret_state = SSLSocket_createContext(net, opts)) == 0)
+	{
+		if (net->ssl == NULL)
+		{
+			net->ssl = malloc(sizeof(mbedtls_ssl_context)); // free in SSLSocket_close
+			if (net->ssl == NULL)
+			{
+				Log(TRACE_PROTOCOL, -1, "allocate ssl context failed.\n");
+				goto exit;
+			}
+			mbedtls_ssl_init(net->ssl);
+		}
+		if ((ret_state = mbedtls_ssl_setup(net->ssl, &net->ctx->conf)) != 0)
+		{
+			Log(TRACE_PROTOCOL, 1, "failed! mbedtls_ssl_setup returned %d \n", ret_state);
+			goto exit;
+		}
+#ifdef MBEDTLS_USE_CRT
+		char *hostname_plus_null;
+		hostname_plus_null = malloc(hostname_len + 1u );
+		if (hostname_plus_null == NULL)
+		{
+			Log(TRACE_PROTOCOL, -1, "allocate hostname_plus_null failed.\n");
+			goto exit;
+		}
+		MQTTStrncpy(hostname_plus_null, hostname, hostname_len + 1u);
+		if ((ret_state = mbedtls_ssl_set_hostname(net->ssl, hostname_plus_null)) != 0)
+		{
+			Log(TRACE_PROTOCOL, 1, "failed! mbedtls_ssl_set_hostname returned %d \n", ret_state);
+			free(hostname_plus_null);
+			goto exit;
+		}
+		free(hostname_plus_null);
+#endif
+		mbedtls_ssl_set_bio(net->ssl, &net->socket, mbedtls_net_send, mbedtls_net_recv, NULL);
+	}
+
+	if (ret_state == 0)
+		rc = 1;
+
+exit:
+	FUNC_EXIT_RC(rc);
+	return rc;
+}
+
+/*
+ * Return value: 1 - success, TCPSOCKET_INTERRUPTED - try again, anything else is failure
+ */
+int SSLSocket_connect(SSL* ssl, int sock, const char* hostname, int verify, int (*cb)(const char *str, size_t len, void *u), void* u)
+{
+	int rc = 1;
+	int ret_state = 0;
+	(void)sock;
+	(void)hostname;
+	(void)verify;
+	(void)cb;
+	(void)u;
+	FUNC_ENTRY;
+
+	ret_state = mbedtls_ssl_handshake(ssl);
+
+	if (ret_state == MBEDTLS_ERR_SSL_WANT_READ ||
+			ret_state == MBEDTLS_ERR_SSL_WANT_WRITE ||
+			ret_state == MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS ||
+			ret_state == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS)
+	{
+		rc = TCPSOCKET_INTERRUPTED;
+	}
+	else if (ret_state == 0)
+	{
+		/* handshake complete check server certificate */
+		Log(TRACE_MIN, -1, "ssl handshake complete.\n");
+#if !defined(IOT_LITEOS_ADAPT)
+		rc = 1;
+#else
+        rc = 0;
+#endif
+	} else {
+		rc = SSL_FATAL;
+		Log(TRACE_PROTOCOL, -1, "failed! mbedtls_ssl_handshake returned -0x%x\n", ret_state);
+	}
+	FUNC_EXIT_RC(rc);
+	return rc;
+}
+
+
+/**
+ *  Reads one byte from a socket
+ *  @param socket the socket to read from
+ *  @param c the character read, returned
+ *  @return completion code
+ */
+int SSLSocket_getch(SSL* ssl, int socket, char* c)
+{
+	int rc = SOCKET_ERROR;
+	if (ssl == NULL || c == NULL)
+		goto exit;
+
+	FUNC_ENTRY;
+	if ((rc = SocketBuffer_getQueuedChar(socket, c)) != SOCKETBUFFER_INTERRUPTED)
+		goto exit;
+
+	if ((rc = mbedtls_ssl_read(ssl, (unsigned char *)c, (size_t)1)) < 0)
+	{
+		Log(TRACE_MIN, -1, "[%s,%d]rc = %d", __func__, __LINE__, rc);
+		if (rc == MBEDTLS_ERR_SSL_WANT_READ || rc == MBEDTLS_ERR_SSL_WANT_WRITE)
+		{
+			rc = TCPSOCKET_INTERRUPTED;
+			SocketBuffer_interrupted(socket, 0);
+		}
+		else
+		{
+			rc = SOCKET_ERROR;
+		}
+	}
+	else if (rc == 0)
+	{
+		rc = SOCKET_ERROR;  /* The return value from recv is 0 when the peer has performed an orderly shutdown. */
+	}
+	else if (rc == 1)
+	{
+		SocketBuffer_queueChar(socket, *c);
+		rc = TCPSOCKET_COMPLETE;
+	}
+exit:
+	FUNC_EXIT_RC(rc);
+	return rc;
+}
+
+
+/**
+ *  Attempts to read a number of bytes from a socket, non-blocking. If a previous read did not
+ *  finish, then retrieve that data.
+ *  @param socket the socket to read from
+ *  @param bytes the number of bytes to read
+ *  @param actual_len the actual number of bytes read
+ *  @return completion code
+ */
+char *SSLSocket_getdata(SSL* ssl, int socket, size_t bytes, size_t* actual_len, int* rc)
+{
+	char* buf = NULL;
+	if (ssl == NULL || actual_len == NULL || rc == NULL)
+		goto exit;
+
+	FUNC_ENTRY;
+	if (bytes == 0)
+	{
+		buf = SocketBuffer_complete(socket);
+		goto exit;
+	}
+
+	buf = SocketBuffer_getQueuedData(socket, bytes, actual_len);
+
+	if ((*rc = mbedtls_ssl_read(ssl, (unsigned char *)(buf + (*actual_len)), (int)(bytes - (*actual_len)))) < 0)
+	{
+		Log(TRACE_MIN, -1, "[%s,%d]rc = %d", __func__, __LINE__, *rc);
+		if (*rc != MBEDTLS_ERR_SSL_WANT_READ && *rc != MBEDTLS_ERR_SSL_WANT_WRITE)
+		{
+			buf = NULL;
+			goto exit;
+		}
+	}
+	else if (*rc == 0) /* rc 0 means the other end closed the socket */
+	{
+		buf = NULL;
+		goto exit;
+	}
+	else
+	{
+		*actual_len += *rc;
+	}
+
+	if (*actual_len == bytes)
+	{
+		SocketBuffer_complete(socket);
+		/* if we read the whole packet, there might still be data waiting in the SSL buffer, which
+		isn't picked up by select.  So here we should check for any data remaining in the SSL buffer, and
+		if so, add this socket to a new "pending SSL reads" list.
+		*/
+		if (mbedtls_ssl_get_bytes_avail(ssl) > 0) /* return no of bytes pending */
+			SSLSocket_addPendingRead(socket);
+	}
+	else /* we didn't read the whole packet */
+	{
+		SocketBuffer_interrupted(socket, *actual_len);
+		Log(TRACE_MAX, -1, "SSL_read: %u bytes expected but %u bytes now received", bytes, *actual_len);
+	}
+exit:
+	FUNC_EXIT;
+	return buf;
+}
+
+void SSLSocket_destroyContext(networkHandles* net)
+{
+	FUNC_ENTRY;
+	if (net != NULL && net->ctx != NULL)
+	{
+		mbedtls_ssl_config_free(&net->ctx->conf);
+		mbedtls_ctr_drbg_free(&net->ctx->ctr_drbg);
+		mbedtls_entropy_free(&net->ctx->entropy);
+#ifdef MBEDTLS_USE_CRT
+		mbedtls_x509_crt_free(&net->ctx->cacert);
+		mbedtls_x509_crt_free(&net->ctx->clicert);
+		mbedtls_pk_free(&net->ctx->pkey);
+#endif
+		free(net->ctx);
+		net->ctx = NULL;
+	}
+	FUNC_EXIT;
+}
+
+static List pending_reads = {NULL, NULL, NULL, 0, 0};
+
+int SSLSocket_close(networkHandles* net)
+{
+	int rc = 1;
+	if (net == NULL)
+		return rc;
+
+	FUNC_ENTRY;
+	/* clean up any pending reads for this socket */
+	if (pending_reads.count > 0 && ListFindItem(&pending_reads, &net->socket, intcompare) != NULL)
+		ListRemoveItem(&pending_reads, &net->socket, intcompare);
+
+	if (net->ssl != NULL)
+	{
+		rc = mbedtls_ssl_close_notify(net->ssl);
+		mbedtls_ssl_free(net->ssl);
+		free(net->ssl);
+		net->ssl = NULL;
+	}
+	SSLSocket_destroyContext(net);
+	FUNC_EXIT_RC(rc);
+	return rc;
+}
+
+static int SSLSocket_buflenCheck(const iobuf* iovec)
+{
+
+	if (iovec->iov_len > SSL_MAX_COUNT)
+	{
+		return SOCKET_ERROR;
+	}
+
+#if defined(SEND_MAX_LEN)
+	if (iovec->iov_len + SSL_HEADER_LEN > SEND_MAX_LEN)
+	{
+		char array[LOG_LEN];
+		int rc = sprintf_s(array, LOG_LEN, "[Error]:Please don't send a message longer than %d bytes."
+				" Message length which contains header and payload is %u bytes.\r\n", SEND_MAX_LEN,
+				iovec->iov_len + SSL_HEADER_LEN);
+		if (rc != -1)
+			app_at_send_at_rsp_string_lines_with_claim_and_log_restricted(array);
+		return  EXT_SOCKET_RET_MESSAGE_TOO_LONG;
+	}
+#endif
+	return 0;
+}
+
+static int SSLSocket_putdatasub(iobuf* iovec, const char* buf0, size_t buf0len, PacketBuffers* bufs)
+{
+	int i;
+	char *ptr;
+	int len = 0;
+	int mem_ret = -1;
+
+	ptr = iovec->iov_base = (char *)malloc(iovec->iov_len);
+	len = iovec->iov_len;
+	if (ptr == NULL)
+	{
+		return PAHO_MEMORY_ERROR;
+	}
+	mem_ret = memcpy_s(ptr, len, buf0, buf0len);
+	if (mem_ret != 0)
+	{
+		free(iovec->iov_base);
+		iovec->iov_base = NULL;
+		return PAHO_MEMORY_ERROR;
+	}
+	ptr += buf0len;
+	len -= buf0len;
+	for (i = 0; i < bufs->count; i++)
+	{
+		if (bufs->buffers[i] != NULL && bufs->buflens[i] > 0)
+		{
+			mem_ret = memcpy_s(ptr, len, bufs->buffers[i], bufs->buflens[i]);
+			if (mem_ret != 0)
+			{
+				free(iovec->iov_base);
+				iovec->iov_base = NULL;
+				return PAHO_MEMORY_ERROR;
+			}
+			ptr += bufs->buflens[i];
+			len -= bufs->buflens[i];
+		}
+	}
+	return 0;
+}
+
+static int SSL_write(SSL* ssl, int socket, iobuf* iovec)
+{
+	int rc;
+	if ((rc = mbedtls_ssl_write(ssl, iovec->iov_base, iovec->iov_len)) == (int)iovec->iov_len)
+	{
+		return TCPSOCKET_COMPLETE;
+	}
+	else
+	{
+		Log(TRACE_MIN, -1, "[%s,%d]rc = %d", __func__, __LINE__, rc);
+		if (rc == MBEDTLS_ERR_SSL_WANT_READ ||
+			rc == MBEDTLS_ERR_SSL_WANT_WRITE ||
+			rc == MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS ||
+			rc == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS ||
+			rc == MBEDTLS_ERR_SSL_CLIENT_RECONNECT)
+		{
+			int* sockmem = (int*)malloc(sizeof(int));
+			int free = 1;
+
+			if (sockmem != NULL)
+			{
+				Log(TRACE_MIN, -1, "Partial write: incomplete write of %d bytes on SSL socket %d",
+					iovec->iov_len, socket);
+				SocketBuffer_pendingWrite(socket, ssl, 1, iovec, &free, iovec->iov_len, 0);
+				*sockmem = socket;
+				ListAppend(mod_s.write_pending, sockmem, sizeof(int));
+#if defined(USE_SELECT)
+				FD_SET(socket, &(mod_s.pending_wset));
+#endif
+				return TCPSOCKET_INTERRUPTED;
+			}
+			else
+			{
+				return PAHO_MEMORY_ERROR;
+			}
+		}
+#if defined(IOT_CONNECT)
+		else if (rc == EXT_SOCKET_RET_SLIDING_WINDOW_FULL)
+		{
+			return EXT_SOCKET_RET_SLIDING_WINDOW_FULL;
+		}
+#endif
+		else
+		{
+			return SOCKET_ERROR;
+		}
+	}
+	return 0;
+}
+
+/* No SSL_writev() provided by OpenSSL. Boo. */
+int SSLSocket_putdatas(SSL* ssl, int socket, char* buf0, size_t buf0len, PacketBuffers bufs)
+{
+	int rc = 0;
+	int i;
+	iobuf iovec;
+
+	if (ssl == NULL || buf0 == NULL || bufs.buffers == NULL || bufs.buflens == NULL || bufs.frees == NULL)
+	{
+		rc = SOCKET_ERROR;
+		goto exit;
+	}
+	if (bufs.count > SSL_MAX_COUNT)
+	{
+		rc = SOCKET_ERROR;
+		goto exit;
+	}
+
+	FUNC_ENTRY;
+	iovec.iov_len = (ULONG)buf0len;
+	for (i = 0; i < bufs.count; i++)
+		iovec.iov_len += (ULONG)bufs.buflens[i];
+
+	rc = SSLSocket_buflenCheck(&iovec);
+	if (rc != 0)
+		goto exit;
+
+	rc = SSLSocket_putdatasub(&iovec, buf0, buf0len, &bufs);
+	if (rc != 0)
+		goto exit;
+
+	SSL_lock_mutex(&sslCoreMutex);
+	rc = SSL_write(ssl, socket, &iovec);
+	SSL_unlock_mutex(&sslCoreMutex);
+
+	if (rc != TCPSOCKET_INTERRUPTED)
+	{
+		free(iovec.iov_base);
+		iovec.iov_base = NULL;
+	}
+	else
+	{
+		free(buf0);
+		for (i = 0; i < bufs.count; ++i)
+		{
+			if (bufs.frees[i] != 0)
+			{
+				free(bufs.buffers[i]);
+				bufs.buffers[i] = NULL;
+			}
+		}
+	}
+
+exit:
+	FUNC_EXIT_RC(rc);
+	return rc;
+}
+
+
+void SSLSocket_addPendingRead(int sock)
+{
+	FUNC_ENTRY;
+	if (ListFindItem(&pending_reads, &sock, intcompare) == NULL) /* make sure we don't add the same socket twice */
+	{
+		int* psock = (int*)malloc(sizeof(sock));
+		if (psock != NULL)
+		{
+			*psock = sock;
+			ListAppend(&pending_reads, psock, sizeof(sock));
+		}
+	}
+	else
+	{
+		Log(TRACE_MIN, -1, "SSLSocket_addPendingRead: socket %d already in the list", sock);
+	}
+
+	FUNC_EXIT;
+}
+
+
+int SSLSocket_getPendingRead(void)
+{
+	int sock = -1;
+
+	if (pending_reads.count > 0)
+	{
+		sock = *(int*)(pending_reads.first->content);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		_ListRemoveHead(&pending_reads); // conflict with libbt_host.a
+#else
+		ListRemoveHead(&pending_reads);
+#endif
+	}
+	return sock;
+}
+
+
+int SSLSocket_continueWrite(pending_writes* pw)
+{
+	int rc = 0;
+	if (pw == NULL)
+		return rc;
+
+	#if defined(SEND_MAX_LEN)
+		if (pw->iovecs[0].iov_len + SSL_HEADER_LEN > SEND_MAX_LEN)
+		{
+			char array[LOG_LEN];
+			int rc = sprintf_s(array, LOG_LEN, "[Error]:Please don't send a message longer than %d bytes."
+					" Message length which contains header and payload is %u bytes.\r\n", SEND_MAX_LEN,
+					pw->iovecs[0].iov_len + SSL_HEADER_LEN);
+			if (rc != -1)
+				app_at_send_at_rsp_string_lines_with_claim_and_log_restricted(array);
+			return EXT_SOCKET_RET_MESSAGE_TOO_LONG;
+		}
+	#endif
+
+	FUNC_ENTRY;
+	if ((rc = mbedtls_ssl_write(pw->ssl, pw->iovecs[0].iov_base, pw->iovecs[0].iov_len)) == (int)pw->iovecs[0].iov_len)
+	{
+		/* topic and payload buffers are freed elsewhere, when all references to them have been removed */
+		free(pw->iovecs[0].iov_base);
+		pw->iovecs[0].iov_base = NULL;
+		Log(TRACE_MIN, -1, "SSL continueWrite: partial write now complete for socket %d", pw->socket);
+		rc = 1;
+	}
+	else
+	{
+		Log(TRACE_MIN, -1, "[%s,%d]rc = %d", __func__, __LINE__, rc);
+		if (rc == MBEDTLS_ERR_SSL_WANT_READ ||
+			rc == MBEDTLS_ERR_SSL_WANT_WRITE ||
+			rc == MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS ||
+			rc == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS ||
+			rc == MBEDTLS_ERR_SSL_CLIENT_RECONNECT)
+			rc = 0; /* indicate we haven't finished writing the payload yet */
+	}
+	FUNC_EXIT_RC(rc);
+	return rc;
+}
+
+#endif
diff -Naru paho.mqtt.c/src/StackTrace.c paho.mqtt.c_new/src/StackTrace.c
--- paho.mqtt.c/src/StackTrace.c	2025-02-12 14:43:09.753734500 +0800
+++ paho.mqtt.c_new/src/StackTrace.c	2025-02-12 14:11:54.462411500 +0800
@@ -66,7 +66,7 @@
 static threadEntry threads[MAX_THREADS];
 static threadEntry *my_thread = NULL;
 
-#if defined(_WIN32) || defined(_WIN64)
+#if defined(_WIN32) || defined(_WIN64) || defined(COMPAT_CMSIS)
 mutex_type stack_mutex;
 #else
 static pthread_mutex_t stack_mutex_store = PTHREAD_MUTEX_INITIALIZER;
diff -Naru paho.mqtt.c/src/StackTrace.h paho.mqtt.c_new/src/StackTrace.h
--- paho.mqtt.c/src/StackTrace.h	2025-02-12 14:43:09.797382500 +0800
+++ paho.mqtt.c_new/src/StackTrace.h	2025-02-12 14:11:54.462411500 +0800
@@ -34,7 +34,11 @@
 #define FUNC_EXIT_NOLOG
 #define FUNC_EXIT_MED
 #define FUNC_EXIT_MAX
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+#define FUNC_EXIT_RC(x)  (void)(x)
+#else
 #define FUNC_EXIT_RC(x)
+#endif
 #define FUNC_EXIT_MED_RC(x)
 #define FUNC_EXIT_MAX_RC(x)
 #else
diff -Naru paho.mqtt.c/src/Thread.c paho.mqtt.c_new/src/Thread.c
--- paho.mqtt.c/src/Thread.c	2025-02-12 14:43:09.837063500 +0800
+++ paho.mqtt.c_new/src/Thread.c	2025-02-12 14:11:54.462411500 +0800
@@ -38,7 +38,7 @@
 #undef realloc
 #undef free
 
-#if !defined(_WIN32) && !defined(_WIN64)
+#if !defined(_WIN32) && !defined(_WIN64) && !defined (COMPAT_CMSIS)
 #include <errno.h>
 #include <unistd.h>
 #include <sys/time.h>
@@ -48,9 +48,15 @@
 #include <limits.h>
 #endif
 #include <stdlib.h>
-
 #include "OsWrapper.h"
-
+#if defined(IOT_CONNECT)
+#include "atiny_mqtt_commu.h"
+#endif
+#if defined (IOT_LITEOS_ADAPT)
+#include "los_task.h"
+#define MQTT_TASK_PRIO  10
+#define MQTT_TASK_STACK_SIZE  0x1000
+#endif
 /**
  * Start a new thread
  * @param fn the function to run, must be of the correct signature
@@ -60,6 +66,10 @@
 {
 #if defined(_WIN32) || defined(_WIN64)
 	thread_type thread = NULL;
+#elif defined (IOT_CONNECT)
+	new_mqtt_run_job(fn, parameter);
+#elif defined (IOT_LITEOS_ADAPT)
+    thread_type thread = 0;
 #else
 	thread_type thread = 0;
 	pthread_attr_t attr;
@@ -69,6 +79,19 @@
 #if defined(_WIN32) || defined(_WIN64)
 	thread = CreateThread(NULL, 0, fn, parameter, 0, NULL);
     CloseHandle(thread);
+#elif defined (IOT_CONNECT)
+
+#elif defined (IOT_LITEOS_ADAPT)
+    TSK_INIT_PARAM_S app_task;
+    /* create task for send_start_report */
+    app_task.pfnTaskEntry = (TSK_ENTRY_FUNC)fn;
+    app_task.uwStackSize  = MQTT_TASK_STACK_SIZE;
+    app_task.pcName = "mqtt";
+    app_task.usTaskPrio = MQTT_TASK_PRIO;
+    app_task.uwResved   = LOS_TASK_STATUS_DETACHED;
+
+    if (LOS_TaskCreate((UINT32 *)&thread, &app_task) != 0)
+        thread = 0;
 #else
 	pthread_attr_init(&attr);
 	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
@@ -127,6 +150,9 @@
 	#if defined(_WIN32) || defined(_WIN64)
 		mutex = CreateMutex(NULL, 0, NULL);
 		*rc = (mutex == NULL) ? GetLastError() : 0;
+	#elif defined (COMPAT_CMSIS)
+		mutex = osMutexNew(NULL);
+		*rc = (mutex == NULL) ? -1 : 0;
 	#else
 		mutex = malloc(sizeof(pthread_mutex_t));
 		if (mutex)
@@ -149,6 +175,8 @@
 	#if defined(_WIN32) || defined(_WIN64)
 		/* WaitForSingleObject returns WAIT_OBJECT_0 (0), on success */
 		rc = WaitForSingleObject(mutex, INFINITE);
+	#elif defined (COMPAT_CMSIS)
+		rc = osMutexAcquire(mutex, osWaitForever);
 	#else
 		rc = pthread_mutex_lock(mutex);
 	#endif
@@ -173,6 +201,8 @@
 			rc = GetLastError();
 		else
 			rc = 0;
+	#elif defined (COMPAT_CMSIS)
+		rc = osMutexRelease(mutex);
 	#else
 		rc = pthread_mutex_unlock(mutex);
 	#endif
@@ -187,11 +217,17 @@
  */
 int Thread_destroy_mutex(mutex_type mutex)
 {
+#if defined(IOT_CONNECT)
+	if (mutex == NULL)
+		return -1;
+#endif
 	int rc = 0;
 
 	FUNC_ENTRY;
 	#if defined(_WIN32) || defined(_WIN64)
 		rc = CloseHandle(mutex);
+	#elif defined (COMPAT_CMSIS)
+		rc = osMutexDelete(mutex);
 	#else
 		rc = pthread_mutex_destroy(mutex);
 		free(mutex);
@@ -209,6 +245,8 @@
 {
 	#if defined(_WIN32) || defined(_WIN64)
 		return GetCurrentThreadId();
+	#elif defined (COMPAT_CMSIS)
+		return osThreadGetId();
 	#else
 		return pthread_self();
 	#endif
@@ -237,6 +275,9 @@
 	#elif defined(OSX)
 		sem = dispatch_semaphore_create(0L);
 		*rc = (sem == NULL) ? -1 : 0;
+	#elif defined (COMPAT_CMSIS)
+		sem = osSemaphoreNew(1, 0, NULL);
+		*rc = (sem == NULL) ? -1 : 0;
 	#else
 		sem = malloc(sizeof(sem_t));
 		if (sem)
@@ -259,7 +300,7 @@
  * so I've used trywait in a loop instead. Ian Craggs 23/7/2010
  */
 	int rc = -1;
-#if !defined(_WIN32) && !defined(_WIN64) && !defined(OSX)
+#if !defined(_WIN32) && !defined(_WIN64) && !defined(OSX) && !defined(COMPAT_CMSIS)
 #define USE_TRYWAIT
 #if defined(USE_TRYWAIT)
 	int i = 0;
@@ -291,6 +332,8 @@
 			}
 			usleep(interval); /* microseconds - .1 of a second */
 		}
+	#elif defined (COMPAT_CMSIS)
+		rc = osSemaphoreAcquire(sem, timeout);
 	#else
 		/* We have to use CLOCK_REALTIME rather than MONOTONIC for sem_timedwait interval.
 		 * Does this make it susceptible to system clock changes?
@@ -346,6 +389,8 @@
 			rc = GetLastError();
 	#elif defined(OSX)
 		rc = (int)dispatch_semaphore_signal(sem);
+	#elif defined (COMPAT_CMSIS)
+		osSemaphoreRelease(sem);
 	#else
 		int val;
 		int rc1 = sem_getvalue(sem, &val);
@@ -373,6 +418,8 @@
 		rc = CloseHandle(sem);
 	#elif defined(OSX)
 	  dispatch_release(sem);
+	#elif defined (COMPAT_CMSIS)
+		rc = osSemaphoreDelete(sem);
 	#else
 		rc = sem_destroy(sem);
 		free(sem);
@@ -388,6 +435,7 @@
  * Create a new condition variable
  * @return the condition variable struct
  */
+#if !defined (COMPAT_CMSIS)
 cond_type Thread_create_cond(int *rc)
 {
 	cond_type condvar = NULL;
@@ -417,11 +465,13 @@
 	FUNC_EXIT_RC(*rc);
 	return condvar;
 }
+#endif
 
 /**
  * Signal a condition variable
  * @return completion code
  */
+#if !defined (COMPAT_CMSIS)
 int Thread_signal_cond(cond_type condvar)
 {
 	int rc = 0;
@@ -434,11 +484,13 @@
 	FUNC_EXIT_RC(rc);
 	return rc;
 }
+#endif
 
 /**
  * Wait with a timeout (ms) for condition variable
  * @return 0 for success, ETIMEDOUT otherwise
  */
+#if !defined (COMPAT_CMSIS)
 int Thread_wait_cond(cond_type condvar, int timeout_ms)
 {
 	int rc = 0;
@@ -474,11 +526,13 @@
 	FUNC_EXIT_RC(rc);
 	return rc;
 }
+#endif
 
 /**
  * Destroy a condition variable
  * @return completion code
  */
+#if !defined (COMPAT_CMSIS)
 int Thread_destroy_cond(cond_type condvar)
 {
 	int rc = 0;
@@ -490,6 +544,7 @@
 	return rc;
 }
 #endif
+#endif
 
 
 #if defined(THREAD_UNIT_TESTS)
diff -Naru paho.mqtt.c/src/Thread.h paho.mqtt.c_new/src/Thread.h
--- paho.mqtt.c/src/Thread.h	2025-02-12 14:43:09.874759300 +0800
+++ paho.mqtt.c_new/src/Thread.h	2025-02-12 14:11:54.466411500 +0800
@@ -45,6 +45,14 @@
 	#define sem_type HANDLE
 	#undef ETIMEDOUT
 	#define ETIMEDOUT WSAETIMEDOUT
+#elif defined(COMPAT_CMSIS)
+	#include <cmsis_os2.h>
+
+	typedef osThreadId_t thread_type;
+	typedef osThreadId_t thread_id_type;
+	typedef osSemaphoreId_t sem_type;
+	#define thread_return_type void*
+	typedef thread_return_type (*thread_fn)(void*);
 #else
 	#include <pthread.h>
 
@@ -76,7 +84,11 @@
 LIBMQTT_API int Thread_unlock_mutex(mutex_type);
 int Thread_destroy_mutex(mutex_type);
 
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+LIBMQTT_API thread_id_type Thread_getid(void);
+#else
 LIBMQTT_API thread_id_type Thread_getid();
+#endif
 
 sem_type Thread_create_sem(int*);
 int Thread_wait_sem(sem_type sem, int timeout);
diff -Naru paho.mqtt.c/src/VersionInfo.h paho.mqtt.c_new/src/VersionInfo.h
--- paho.mqtt.c/src/VersionInfo.h	1970-01-01 08:00:00.000000000 +0800
+++ paho.mqtt.c_new/src/VersionInfo.h	2025-02-12 14:11:54.466411500 +0800
@@ -0,0 +1,7 @@
+#ifndef VERSIONINFO_H
+#define VERSIONINFO_H
+
+#define BUILD_TIMESTAMP "@BUILD_TIMESTAMP@"
+#define CLIENT_VERSION  "@CLIENT_VERSION@"
+
+#endif /* VERSIONINFO_H */
diff -Naru paho.mqtt.c/src/WebSocket.c paho.mqtt.c_new/src/WebSocket.c
--- paho.mqtt.c/src/WebSocket.c	2025-02-12 14:43:10.104904600 +0800
+++ paho.mqtt.c_new/src/WebSocket.c	2025-02-12 14:11:54.478411500 +0800
@@ -80,10 +80,18 @@
 #  endif
 #endif
 
-#if defined(OPENSSL)
+#if defined(IOT_CONNECT)
+#  include <sys/endian.h>
+#endif
+#if defined(OPENSSL) || defined(MBEDTLS)
 #include "SSLSocket.h"
+#endif /* defined(OPENSSL) || defined(MBEDTLS) */
+#if defined(OPENSSL)
 #include <openssl/rand.h>
 #endif /* defined(OPENSSL) */
+#if defined(MBEDTLS)
+#include <entropy_poll.h>
+#endif /* defined(MBEDTLS) */
 #include "Socket.h"
 
 #define HTTP_PROTOCOL(x) x ? "https" : "http"
@@ -108,6 +116,10 @@
 #if defined(OPENSSL)
 	int rc = RAND_bytes( out, sizeof(uuid_t));
 	if ( !rc )
+#elif defined(MBEDTLS) && defined (MBEDTLS_ENTROPY_HARDWARE_ALT)
+	size_t out_len;
+	int rc = mbedtls_hardware_poll( NULL, out, sizeof(uuid_t), &out_len);
+	if (rc != 0)
 #endif /* defined (OPENSSL) */
 	{
 		/* very insecure, but generates a random uuid */
@@ -197,7 +209,11 @@
 			ret = 2; /* header 2 bytes */
 		else if ( data_len < 65536u )
 			ret = 4; /* for extra 2-bytes for payload length */
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		else if ( data_len < 0xFFFFFFFF )
+#else
 		else if ( data_len < 0xFFFFFFFFFFFFFFFF )
+#endif
 			ret = 10; /* for extra 8-bytes for payload length */
 		if ( mask_data & 0x1 )
 			ret += sizeof(uint32_t); /* for mask */
@@ -272,6 +288,9 @@
 			/* generate mask, since we are a client */
 #if defined(OPENSSL)
 			RAND_bytes(&bufs->mask[0], sizeof(bufs->mask));
+#elif defined(MBEDTLS) && defined (MBEDTLS_ENTROPY_HARDWARE_ALT)
+		size_t out_len;
+		mbedtls_hardware_poll( NULL, &bufs->mask[0], sizeof(bufs->mask), &out_len );
 #else /* if defined(OPENSSL) */
 			bufs->mask[0] = (rand() % UINT8_MAX);
 			bufs->mask[1] = (rand() % UINT8_MAX);
@@ -302,7 +321,11 @@
 			memcpy( &rc.wsbuf0[buf_len], &len, 2u );
 			buf_len += 2;
 		}
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		else if ( data_len < 0xFFFFFFFF )
+#else
 		else if ( data_len < 0xFFFFFFFFFFFFFFFF )
+#endif
 		{
 			uint64_t len = htobe64((uint64_t)data_len);
 			rc.wsbuf0[buf_len++] |= (127u & 0x7F);
@@ -466,7 +489,7 @@
 #else
 			HTTP_PROTOCOL(0),
 #endif
-			
+
 			(int)hostname_len, uri, port,
 			net->websocket_key,
 			headers_buf ? headers_buf : "");
@@ -489,13 +512,23 @@
 	{
 		PacketBuffers nulbufs = {0, NULL, NULL, NULL, {0, 0, 0, 0}};
 
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 		if (net->ssl)
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			rc = SSLSocket_putdatas(net->ssl, net->socket, buf, buf_len, nulbufs);
+#else
 			SSLSocket_putdatas(net->ssl, net->socket, buf, buf_len, nulbufs);
+#endif
 		else
 #endif
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			rc = Socket_putdatas(net->socket, buf, buf_len, nulbufs);
+		if (rc != TCPSOCKET_INTERRUPTED)
+			free( buf );
+#else
 			Socket_putdatas(net->socket, buf, buf_len, nulbufs);
 		free( buf );
+#endif
 		rc = 1;
 	}
 	else
@@ -524,6 +557,9 @@
 	FUNC_ENTRY;
 	if ( net->websocket )
 	{
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		int rc;
+#endif
 		char *buf0;
 		size_t buf0len = sizeof(uint16_t);
 		uint16_t status_code_be;
@@ -550,14 +586,25 @@
 
 		fd = WebSocket_buildFrame( net, WebSocket_OP_CLOSE, mask_data, &buf0, &buf0len, &nulbufs);
 
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 		if (net->ssl)
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			rc = SSLSocket_putdatas(net->ssl, net->socket, fd.wsbuf0, fd.wsbuf0len, nulbufs);
+#else
 			SSLSocket_putdatas(net->ssl, net->socket, fd.wsbuf0, fd.wsbuf0len, nulbufs);
+#endif
 		else
 #endif
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			rc = Socket_putdatas(net->socket, fd.wsbuf0, fd.wsbuf0len, nulbufs);
+
+		if (rc != TCPSOCKET_INTERRUPTED)
+			free(fd.wsbuf0); /* free temporary ws header */
+#else
 			Socket_putdatas(net->socket, fd.wsbuf0, fd.wsbuf0len, nulbufs);
 
 		free(fd.wsbuf0); /* free temporary ws header */
+#endif
 
 		/* websocket connection is now closed */
 		net->websocket = 0;
@@ -617,7 +664,7 @@
 			rc = TCPSOCKET_COMPLETE;
 		}
 	}
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	else if ( net->ssl )
 		rc = SSLSocket_getch(net->ssl, net->socket, c);
 #endif
@@ -740,7 +787,7 @@
 			}
 		}
 	}
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	else if ( net->ssl )
 		rv = SSLSocket_getdata(net->ssl, net->socket, bytes, actual_len, &rc);
 #endif
@@ -790,9 +837,9 @@
 	}
 
 	*actual_len = 0;
-	
+
 	// not enough data in the buffer, get data from socket
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	if ( net->ssl )
 		rv = SSLSocket_getdata(net->ssl, net->socket, bytes, actual_len, rc);
 	else
@@ -811,7 +858,7 @@
 		frame_buffer_index = 0;
 		frame_buffer_data_len = 0;
 		frame_buffer_len = 0;
-		
+
 		if (frame_buffer)
 		{
 			free (frame_buffer);
@@ -853,11 +900,11 @@
 
 		SocketBuffer_complete(net->socket);
 	}
-	else 
+	else
 		goto exit;
 
 	bytes = bytes_requested;
-    
+
 	// if possible, return data from the buffer
 	if (bytes > 0)
 	{
@@ -892,6 +939,9 @@
 	FUNC_ENTRY;
 	if ( net->websocket )
 	{
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		int rc;
+#endif
 		char *buf0 = NULL;
 		size_t buf0len = 0;
 		int freeData = 0;
@@ -903,14 +953,24 @@
 
 		Log(TRACE_PROTOCOL, 1, "Sending WebSocket PONG" );
 
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 		if (net->ssl)
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			rc = SSLSocket_putdatas(net->ssl, net->socket, fd.wsbuf0, fd.wsbuf0len /*header_len + app_data_len*/, appbuf);
+#else
 			SSLSocket_putdatas(net->ssl, net->socket, fd.wsbuf0, fd.wsbuf0len /*header_len + app_data_len*/, appbuf);
+#endif
 		else
 #endif
-			Socket_putdatas(net->socket, fd.wsbuf0, fd.wsbuf0len /*header_len + app_data_len*/, appbuf);
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+			rc = Socket_putdatas(net->socket, fd.wsbuf0, fd.wsbuf0len /*header_len + app_data_len*/, appbuf);
 
+		if (rc != TCPSOCKET_INTERRUPTED)
+			free(fd.wsbuf0);
+#else
+			Socket_putdatas(net->socket, fd.wsbuf0, fd.wsbuf0len /*header_len + app_data_len*/, appbuf);
 		free(fd.wsbuf0);
+#endif
 		free(buf0);
 	}
 	FUNC_EXIT;
@@ -948,7 +1008,7 @@
 
 		wsdata = WebSocket_buildFrame(net, WebSocket_OP_BINARY, mask_data, buf0, buf0len, bufs);
 
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 		if (net->ssl)
 			rc = SSLSocket_putdatas(net->ssl, net->socket, wsdata.wsbuf0, wsdata.wsbuf0len, *bufs);
 		else
@@ -964,7 +1024,7 @@
 	}
 	else
 	{
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 		if (net->ssl)
 			rc = SSLSocket_putdatas(net->ssl, net->socket, *buf0, *buf0len, *bufs);
 		else
@@ -996,11 +1056,21 @@
 
 	FUNC_ENTRY;
 	if ( !in_frames )
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+	{
+#endif
 		in_frames = ListInitialize();
-
+#if defined(IOT_CONNECT) || defined(IOT_LITEOS_ADAPT)
+		if (in_frames == NULL)
+		{
+			rc = SOCKET_ERROR;
+			goto exit;
+		}
+	}
+#endif
 	/* see if there is frame currently on queue */
 	if ( in_frames->first )
-		res = in_frames->first->content;
+		{res = in_frames->first->content;}
 
 	//while( !res )
 	//{
@@ -1030,7 +1100,7 @@
 				{
 					rc = TCPSOCKET_INTERRUPTED;
 					goto exit;
-				} 
+				}
 				else if (len < 2u )
 				{
 					rc = TCPSOCKET_INTERRUPTED;
@@ -1073,7 +1143,7 @@
 					{
 						rc = SOCKET_ERROR;
 						goto exit;
-					} 
+					}
 					else if (len < 2u )
 					{
 						rc = TCPSOCKET_INTERRUPTED;
@@ -1096,7 +1166,7 @@
 					{
 						rc = SOCKET_ERROR;
 						goto exit;
-					} 
+					}
 					else if (len < 8u )
 					{
 						rc = TCPSOCKET_INTERRUPTED;
@@ -1139,7 +1209,7 @@
 				{
 					rc = SOCKET_ERROR;
 					goto exit;
-				} 
+				}
 				if (len < payload_len )
 				{
 					rc = TCPSOCKET_INTERRUPTED;
@@ -1275,19 +1345,19 @@
 		free( last_frame );
 		last_frame = NULL;
 	}
-	
+
 	if ( frame_buffer )
 	{
 		free( frame_buffer );
 		frame_buffer = NULL;
 	}
-	
+
 	frame_buffer_len = 0;
 	frame_buffer_index = 0;
 	frame_buffer_data_len = 0;
 
 	Socket_outTerminate();
-#if defined(OPENSSL)
+#if defined(OPENSSL) || defined(MBEDTLS)
 	SSLSocket_terminate();
 #endif
 	FUNC_EXIT;
@@ -1331,7 +1401,7 @@
 			goto exit;
 
 		if ((read_buf == NULL) || rcv < 12u) {
-			Log(TRACE_PROTOCOL, 1, "WebSocket upgrade read not complete %lu", rcv );
+			Log(TRACE_PROTOCOL, 1, "WebSocket upgrade read not complete %lu", (unsigned long)rcv );
 			rc = TCPSOCKET_INTERRUPTED;
 			goto exit;
 		}
@@ -1357,7 +1427,7 @@
 			/* Did we read the whole response? */
 			if (read_buf && rcv > 4 && memcmp(&read_buf[rcv-4], "\r\n\r\n", 4) != 0)
 			{
-				Log(TRACE_PROTOCOL, -1, "WebSocket HTTP upgrade response read not complete %lu", rcv);
+				Log(TRACE_PROTOCOL, -1, "WebSocket HTTP upgrade response read not complete %lu", (unsigned long)rcv);
 				rc = SOCKET_ERROR;
 				goto exit;
 			}
